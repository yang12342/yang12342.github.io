
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title> | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/9
        </span>
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据结构
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #03a9f4">
                    数据结构
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="AVL树解析（基于查找二叉树（dynamicSearchTree））"><a href="#AVL树解析（基于查找二叉树（dynamicSearchTree））" class="headerlink" title="AVL树解析（基于查找二叉树（dynamicSearchTree））"></a>AVL树解析（基于查找二叉树（dynamicSearchTree））</h1><h2 id="平衡二叉树："><a href="#平衡二叉树：" class="headerlink" title="平衡二叉树："></a>平衡二叉树：</h2><p>在查找二叉树的基础上要求每个节点左右字节点的高度差不能超过一。</p>
<p>于是对于节点多了一个数据成员高度来实现这一功能。</p>
<span id="more"></span>

<ul>
<li>先附上源代码</li>
</ul>
<pre><code class="C++">#include &quot;dynamicSearchTable.h&quot;

template &lt;class KEY, class OTHER&gt;
struct SET
&#123;
    KEY key;																		//关键字信息
    OTHER other;																	//和其他信息
&#125;;

template &lt;class KEY,class OTHER&gt;
class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;
&#123;
    struct AvlNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        AvlNode* left;
        AvlNode* right;
        int height;																	

        AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h)&#123;&#125;
    &#125;;

    AvNodee* root;

public:
    AvlTree() &#123; root = NULL;&#125;
    ~AvlTree() &#123; makeEmpty(root);&#125;
    SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const;
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x);
    void remove(const KEY&amp; x);
private:
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t);
    bool remove(const KEY&amp; x, AvlNode*&amp; t);
    void makeEmpty(AvlNode* t);
    int height(AvlNode* t)const &#123; return t == NULL ? 0 : t-&gt;height;&#125;
    void LL(AvlNode*&amp; t);
    void LR(AvlNode*&amp; t);
    void RL(AvlNode*&amp; t);
    void RR(AvlNode*&amp; t);
    int max(int a, int b) &#123; return (a &gt; b) ? a : b;&#125;
    bool adjust(AvlNode*&amp; t, int subTree);
&#125;;


template &lt;class KEY, class OTHER&gt;
SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const
&#123;
    AvlNode* t = root;

    while (t != NULL &amp;&amp; t-&gt;data.key != x)						
    &#123;																		
        if (t-&gt;data.key &gt; x)t = t-&gt;left;						
        else t = t-&gt;right;
    &#125;
    if (t == NULL)return NULL;
    else return (SET&lt;KEY, OTHER&gt;*)t;							
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t)					
&#123;
    AvlNode* t1 = t-&gt;left;									
    t-&gt;left = t1-&gt;right;									
    t1-&gt;right = t;											
    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;	
    t1-&gt;height = max(height(t-&gt;left), height(t)) + 1;
    t = t1;													
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t)					
&#123;
    AvlNode* t1 = t-&gt;right;
    t-&gt;right = t1-&gt;left;
    t1-&gt;left = t;
    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;
    t1-&gt;height = max(height(t-&gt;right), height(t)) + 1;
    t = t1;
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t)				
&#123;
    RR(t-&gt;left);								
    LL(t);
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t)
&#123;
    LL(t-&gt;right);
    RR(t);
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x)
&#123;
    insert(x, root);
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t)
&#123;
    if (t == NULL)											
        t = new AvlNode(x, NULL, NULL);
    else if (x.key &lt; t-&gt;data.key)							
    &#123;
        insert(x, t-&gt;left);									
        if (height(t-&gt;left) - height(t-&gt;right) == 2)		
            if (x.key &lt; t-&gt;left-&gt;data.key)LL(t);			
            else LR(t);
    &#125;
    else if (t-&gt;data.key &lt; x.key)							
    &#123;
        insert(x, t-&gt;right);
        if (height(t-&gt;right) - height(t-&gt;left) == 2)
            if (t-&gt;right-&gt;data.key &lt; x.key)RR(t);
            else LR(t);
    &#125;														
    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;
&#125;

template&lt;class KEY,class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x)
&#123;
    remove(x, root);
&#125;

template&lt;class KEY, class OTHER&gt;
bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t)
&#123;
    if (t == NULL)return true;							
    if (x == t-&gt;data.key)								
    &#123;
        if (t-&gt;left == NULL || t-&gt;right == NULL)		
        &#123;
            AvlNode* oldNode = t;						
            t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right;	
            delete oldNode;
            return false;								
        &#125;
        else
        &#123;
            AvlNode* tmp = t-&gt;right;					
            while (tmp-&gt;left != NULL)tmp = tmp-&gt;left;	
            t-&gt;data = tmp-&gt;data;						
            if (remove(tmp-&gt;data.key, t-&gt;right))return true;
            return adjust(t, 1);						
        &#125;
    &#125;

    if (x &lt; t-&gt;data.key)								
    &#123;
        if (remove(x, x-&gt;left))return true;				
        return adjust(t, 0);							
    &#125;
    else
    &#123;
        if (remove(x, t-&gt;right))return true;
        return adjust(t, 1);							
    &#125;
&#125;

template&lt;class KEY, class OTHER&gt;
bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree)		
&#123;
    if (subTree)													
    &#123;
        if (height(t-&gt;left) - height(t-&gt;right) == 1)return true;	
        if (height(t-&gt;right) == height(t-&gt;left))					
        &#123;
            --t-&gt;height; return false;								
        &#125;
        if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left))			
        &#123;
            LR(t);																				
            return false;											
        &#125;
        LL(t)														
            if (height(t-&gt;right) == height(t-&gt;left))return false;	
            else return true;										
    &#125;																
    else
    &#123;
        if (height(t-&gt;right) - height(t-&gt;left) == 1)return true;	
        if (height(t-&gt;right) == height(t-&gt;left))
        &#123; 
            --t-&gt;height; return false;
        &#125;
        if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))
        &#123;
            RL(t);
            return false;
        &#125;
        RR(t)
            if (height(t-&gt;right) == height(t-&gt;left))return false;
            else return true;
    &#125;
&#125;

template&lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::makeEmpty(AvlNode* t)
&#123;
    if (t == NULL)return;										
    makeEmpty(t-&gt;left);
    makeEmpty(t-&gt;right);
    delete t;
&#125;
</code></pre>
<hr>
<h2 id="基本组成成员"><a href="#基本组成成员" class="headerlink" title="基本组成成员"></a>基本组成成员</h2><ul>
<li>AvlNode（AVL的树节点）</li>
</ul>
<pre><code class="CPP">struct AvlNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        AvlNode* left;
        AvlNode* right;
        int height;																	//节点的高度

        AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, 
                int h=1):data(element),left(lt),right(rt),height(h)&#123;&#125;
    &#125;;
</code></pre>
<p>多了一个高度，构造函数默认为1（指只有自己）</p>
<ul>
<li>根节点</li>
</ul>
<pre><code class="CPP">AvNodee* root;
</code></pre>
<hr>
<h2 id="AVL类的基本数据成员和函数"><a href="#AVL类的基本数据成员和函数" class="headerlink" title="AVL类的基本数据成员和函数"></a>AVL类的基本数据成员和函数</h2><pre><code class="CPP">template &lt;class KEY,class OTHER&gt;
class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;
&#123;
    struct AvlNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        AvlNode* left;
        AvlNode* right;
        int height;																	
        AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h)&#123;&#125;
    &#125;;
    AvNodee* root;

public:
    AvlTree() &#123; root = NULL;&#125;
    ~AvlTree() &#123; makeEmpty(root);&#125;
    SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const;							//查找函数
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x);								//插入函数（公有）
    void remove(const KEY&amp; x);											//删除函数（公有）
private:
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t);					//插入函数（私有）
    bool remove(const KEY&amp; x, AvlNode*&amp; t);								//删除函数（私有）
    void makeEmpty(AvlNode* t);											//清空
    int height(AvlNode* t)const &#123; return t == NULL ? 0 : t-&gt;height;&#125;	//计算当前节点的高度
    void LL(AvlNode*&amp; t);												//单旋转LL
    void LR(AvlNode*&amp; t);												//双旋转LR
    void RL(AvlNode*&amp; t);												//双旋转RL
    void RR(AvlNode*&amp; t);												//单旋转RR
    int max(int a, int b) &#123; return (a &gt; b) ? a : b;&#125;					//比较函数
    bool adjust(AvlNode*&amp; t, int subTree);								//调整节点的结构使其平衡的函数
&#125;;
</code></pre>
<p>其实<strong>private</strong>类的函数都是公有类函数的工具函数</p>
<hr>
<h2 id="函数的实现分析"><a href="#函数的实现分析" class="headerlink" title="函数的实现分析"></a>函数的实现分析</h2><ul>
<li>查找函数（find）</li>
</ul>
<pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const
&#123;
    AvlNode* t = root;
    while (t != NULL &amp;&amp; t-&gt;data.key != x)						//循环停止的条件，就是当前节点为空或者就是要找的
    &#123;															//小于就换成左节点，反之换成右节点，			
        if (t-&gt;data.key &gt; x)t = t-&gt;left;						
        else t = t-&gt;right;
    &#125;
    if (t == NULL)return NULL;									//空就返回
    else return (SET&lt;KEY, OTHER&gt;*)t;							//这里还是强制转换
&#125;
</code></pre>
<p>还是基于二叉查找树的特性，只是没有使用<strong>递归</strong>函数，这种方式被称为<strong>迭代</strong>实现</p>
<hr>
<ul>
<li>插入函数（insert）</li>
</ul>
<p>在介绍函数之前理解一些东西，关于插入的一些特性：</p>
<p><em>1.</em> <strong>首先插入还是和二叉查找树一样插入在叶子节点上</strong></p>
<p><em>2.</em> <strong>一次插入后，只有在插入点到根的路径上的节点才有可能发生平衡度的变化</strong></p>
<p><em>3.</em> <strong>AVL的平衡策略最多只要调整一个节点就可以了</strong></p>
<h4 id="主要分析LL和LR俩种情况"><a href="#主要分析LL和LR俩种情况" class="headerlink" title="主要分析LL和LR俩种情况"></a>主要分析LL和LR俩种情况</h4><p><strong>注意：</strong></p>
<p>对于旋转策略的核心是保证节点的高度不发生变化，就是通过旋转变为原来的高度，从而保证对上面节点安全的保证。</p>
<p>一旦改变了数的高度，那需要不断往上检索，直到那个节点的高度没有发生变化</p>
<p><strong>LL：</strong>原来A的左子树比右子树高，插入发生在A的左儿子的左子树中，使A的左子树增高</p>
<p>(注意（仅仅对于插入而言，对于删除这个结论反而相反）：平衡度只是一种高度是否平衡的表现形式，真正影响的是节点的高度，主要体现在平衡度向零趋近高度不变，而向俩边增长表明节点高度发生改变)</p>
<p>此图有图</p>
<p>节点平衡度从-1到0但是并不影响上面的节点，因为这个节点的高度并未发生改变，反而0到1表明当前节点的高度发生改变</p>
<h5 id="现在来分析LL的情况"><a href="#现在来分析LL的情况" class="headerlink" title="现在来分析LL的情况"></a>现在来分析LL的情况</h5><p>此处有图</p>
<p>首先分析一下一些情况：</p>
<p><em>1.</em> **首先B的平衡度一定原来是0，然后变为1，</p>
<p>因为我们上面解释过如果是-1到0表明是向零趋近，B的高度不会发生变化，进而不会影响A</p>
<p>若是原来是1，变成2，显然B才是危机节点，处理就不是A了</p>
<p>对于LL解决办法就是向右旋转</p>
<p>此处有图</p>
<p>显然我们发现在旋转后我们发现我们处理的这个树的高度与插入前的高度完全一样，于是不用担心上面节点的平衡度了</p>
<p><strong>思考：</strong></p>
<p>对于这种旋转必然是左右子树未实现满二叉树或者完全二叉树导致，就是有空缺的位置来保证旋转后高度不发生变化</p>
<p>那么假设是满二叉树插入，我们会发现并不影响平衡度都从（0到1或者0到-1）</p>
<p>（其实这就是插入点后的检索过程，虽然高度发生了变化，但是一直向上检索发现平衡度没有打破规则，那么就会检索到根节点结束）</p>
<p>现在附上LL代码图</p>
<pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t)			//注意这里传的是原来的指针，估计是父节点的指针，不然改了没意义				A
&#123;
    AvlNode* t1 = t-&gt;left;									//失衡的A，先标记B点为t1（A的左子节点）
    t-&gt;left = t1-&gt;right;									//B的右子树，变成A的左子树
    t1-&gt;right = t;											//B的右子节点变成A
    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;	//此时更新各自的高度（+1是为了包括本身）
    t1-&gt;height = max(height(t-&gt;left), height(t)) + 1;
    t = t1;													//将t彻底变为B点（B成为t的指向点）
&#125;
</code></pre>
<p><strong>有心情的话</strong> 可以在这个补一个过程图，看我以后记不记的住吧</p>
<p>*1.*我们发现指针还是引用传递，主要是我要旋转A点，那么就需要修改A的父节点对应的指针从。原理和二叉查找树的原理相同</p>
<h3 id="RR也是同理只是向左旋转"><a href="#RR也是同理只是向左旋转" class="headerlink" title="RR也是同理只是向左旋转"></a>RR也是同理只是向左旋转</h3><p>附上RR的代码</p>
<pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t)					//这个和上面是一个道理，就是向左转，就像镜像一样
&#123;
    AvlNode* t1 = t-&gt;right;
    t-&gt;right = t1-&gt;left;
    t1-&gt;left = t;
    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;
    t1-&gt;height = max(height(t-&gt;right), height(t)) + 1;
    t = t1;
&#125;
</code></pre>
<hr>
<h4 id="现在来分析LR的情况"><a href="#现在来分析LR的情况" class="headerlink" title="现在来分析LR的情况"></a>现在来分析LR的情况</h4><p>为什么要单独讨论这种情况？<br>因为我们发现仅仅如果使用LL右旋发现只是不过对这个树镜像对称过去了而已，A点仍然是失衡点，只不过是现在是右子树高了</p>
<p>此处有图</p>
<p>我们相对于之前多了一个参考C节点，对于C<sub>L</sub>和C<sub>R</sub>谁的高度为h-1并不重要</p>
<p>为了保证根节点的高度不发生变化，我们选择LR的双旋转的方法，对B点进行左旋转（RR），再对A点进行右旋转（LL）</p>
<p>不难发现，C点占据了原来的根节点，且平衡度恢复了0，因为是1到0我们便可认定节点的高度没有发生变化，从而无需再向上检索</p>
<p>过程如下图显示</p>
<p>其实逻辑也很好理解就是让根节点的右边多一个高度来平衡多的那个节点</p>
<p>代码如下</p>
<pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t)				
&#123;
    RR(t-&gt;left);								//先对B进行左旋
    LL(t);										//再对A点进行右旋
&#125;
</code></pre>
<h4 id="RL也完全是同理，就是对称了一下"><a href="#RL也完全是同理，就是对称了一下" class="headerlink" title="RL也完全是同理，就是对称了一下"></a>RL也完全是同理，就是对称了一下</h4><pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t)
&#123;
    LL(t-&gt;right);
    RR(t);
&#125;
</code></pre>
<hr>
<h3 id="以上我们分析了四种旋转情况接下来就来分析插入函数"><a href="#以上我们分析了四种旋转情况接下来就来分析插入函数" class="headerlink" title="以上我们分析了四种旋转情况接下来就来分析插入函数"></a>以上我们分析了四种旋转情况接下来就来分析插入函数</h3><p>前面我们提到了一个关键词<strong>回溯</strong></p>
<p>对于代码里面的回溯就是在修改后往回检查，最好想的就是树了，我修改了叶节点，我需要对查找路径上的每一个点进行检查，那么我们在代码中如何往回实现这个功能呢？</p>
<p>答案就是利用</p>
<p><strong>递归</strong></p>
<p>假如我们要进行修改，并检查，可以用如下伪代码实现</p>
<pre><code>插入函数
&#123;
检查当前节点是不是插入点，是就插入
不是就根据于当前节点的大小调用“函数（左节点）/函数（右节点）”

//因为是递归调用，执行到这一样表示递归所有的修改已完成开始回溯了
检查当前节点的平衡度来看是否需要调整，若失衡分类讨论

重新计算高度
&#125;
</code></pre>
<p>附上代码</p>
<p>其实我们发现这个回溯必须全部走完，因为要更改高度（尤其是满二叉树那种虽然不影响平衡度，但是路径上所有节点高度都需要+1）</p>
<pre><code class="CPP">template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x)
&#123;
    insert(x, root);
&#125;

template &lt;class KEY, class OTHER&gt;
void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t)
&#123;
    if (t == NULL)											//情况1：如果根节点为空就直接放置
        t = new AvlNode(x, NULL, NULL);
    
    else if (x.key &lt; t-&gt;data.key)							//情况2：如果比当前节点小，往左子树插入
    &#123;
        insert(x, t-&gt;left);									//向下递归
        
        if (height(t-&gt;left) - height(t-&gt;right) == 2)		//执行到这一步表示左子树全部节点都平衡了，检查自己了
            if (x.key &lt; t-&gt;left-&gt;data.key)LL(t);			//当前节点失衡了，只要判断插入节点是在左子节点的左右
                                                            //就可以判断是哪种情况
            else LR(t);
    &#125;

    else if (t-&gt;data.key &lt; x.key)							//这里的逻辑是一样的，参照上面就行了
    &#123;
        insert(x, t-&gt;right);
        if (height(t-&gt;right) - height(t-&gt;left) == 2)
            if (t-&gt;right-&gt;data.key &lt; x.key)RR(t);
            else LR(t);
    &#125;														

    t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;	//在最后插入好，会从底往上重新计算树的高度
&#125;
</code></pre>
<hr>
<ul>
<li>删除函数（remove）</li>
</ul>
<p>删除节点很有可能导致树变矮，导致二叉树失衡，所以必须要在删除后不断回溯调整平衡</p>
<p>首先这是一个<strong>回溯</strong>的过程，还有一个关键点就是是否需要再网上回溯的<strong>关键是:</strong></p>
<p>的当前节点的高度在调整后或者未调整高度是否发生变换，注意我说的是<strong>高度</strong>不是平衡度，若往回检索发现有节点高度未发生变化就可以停止检查调整步骤直接return。</p>
<p>这也表明了虽然删除是递归，但是返回值是一个bool表示当前节点高度是否发生变化从而决定上面的节点是否需要检查</p>
<h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><p>这一个和二叉查找树没什么区别其实，依旧是分为三种情况（无儿子，一个儿子，俩个儿子）</p>
<p>前俩个可以用一个表达式来代替</p>
<pre><code class="CPP">t=（t-&gt;left!=NULL）:t-&gt;left?t-right;
</code></pre>
<p>相对后面的情况显示是迭代找到可替换的叶子节点，然后删除叶子节点啦。</p>
<h4 id="检查过程"><a href="#检查过程" class="headerlink" title="检查过程"></a>检查过程</h4><p>删除的时候没有插入那么幸运，删除时的调整很有可能导致整棵树高度下降，从而影响路上的所有父节点。</p>
<p>停止条件：只有当某个节点读的高度在删除后不变才无需向上检查调整了</p>
<p>导致树的高度发生变化有以下几种情况</p>
<p>（<strong>注意：</strong>这里平衡度是在向两边增长节点高度不变，向零靠近节点高度发生变化，因为是删除</p>
<p>（与插入的结论恰恰相反，插入是有可能增高，而删除是有可能降低高度））</p>
<p>此处有五种情况（假设都是在左子树上删除的节点）</p>
<p>此处有图</p>
<p>对于（a）的平衡度既没有失衡，高度也没有发生变化</p>
<p>对于（b）平衡度没有失衡，但是根据平衡度的变化可以发现节点的高度发生变换，需要检查父节点</p>
<p>对于（c）只需要节点P使用左旋（RR）即可，这样根节点的高度就变成了0，虽然平衡了但是平衡度从-1变为0，节点高度发生变化，需要检查父节点</p>
<p>对于（d）显然左旋仍然导致失衡，就像前面的RL的情况一样发生在内侧，这个时候就需要先对P的右子节点先右旋（LL）再对P进行左旋（RR），就会使根节点平衡度变为0.不需要对父节点进行检查</p>
<p>对于（e）对P使用简单的左旋（RR）根节点（原来P的位置）的平衡度变为1（注意平衡度从-1到1，节点的高度并未发生变化，可以认为就像交换了一样）；当然可以使用RL，这样的话根节点的平衡度仍为-1，高度未发生变化。所以俩种方法都不需要检查父节点</p>
<p>对于添加在右子节点的方法对称就好了</p>
<p>附上代码</p>
<p>（指针参数还是引用，原因上面解释过了）</p>
<p>（true表示不用检查，false表示节点的高度发生变化，需要检查节点的高度）</p>
<ul>
<li><strong>删除函数</strong></li>
</ul>
<pre><code class="CPP">
template&lt;class KEY,class OTHER&gt;
void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x)
&#123;
    remove(x, root);
&#125;

template&lt;class KEY, class OTHER&gt;
bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t)
&#123;
    if (t == NULL)return true;							//空树不存在，不用检查父节点
    if (x == t-&gt;data.key)								//情况1：如果是当前节点
    &#123;
        if (t-&gt;left == NULL || t-&gt;right == NULL)		//删除情况1，2：如果只是有一个子节点或者没有节点
        &#123;
            AvlNode* oldNode = t;						
            t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right;	
            delete oldNode;								//因为对只有一个节点或者无叶节点的删除必然导致高度变换，肯定是
            return false;								//要检查的
        &#125;
        
        else
        &#123;
            AvlNode* tmp = t-&gt;right;					//删除情况三：有俩个子节点
            while (tmp-&gt;left != NULL)tmp = tmp-&gt;left;	//迭代找到右子树的最左子节点
            t-&gt;data = tmp-&gt;data;						//数据替换
            if (remove(tmp-&gt;data.key, t-&gt;right))		//然后就是删除的目标换成最新的叶节点，从当前的节点右节点开始
                return true;							//如果这个删除最后返回的是true，表明右子节点的高度未变化
            
            return adjust(t, 1);						//1表示删除在右子树上，t表示当前节点失衡，需要调整
        &#125;
    &#125;

    if (x &lt; t-&gt;data.key)								//情况2：小于则是向左找
    &#123;
        if (remove(x, x-&gt;left))return true;				//向左递归
        return adjust(t, 0);							//如果需要检查，则调用adjust，0表示删除的是左子树
    &#125;
    
    else												//情况三：大于则是向右找
    &#123;
        if (remove(x, t-&gt;right))return true;
        return adjust(t, 1);							
    &#125;
&#125;
</code></pre>
<p>这段逻辑其实挺绕人的，remove函数的返回值主要三种：</p>
<p><em>1：</em>删除的是只有一个字节点或者无子节点（直接返回true，必然改变高度）</p>
<p><em>2：</em>向下递归调用remove，如果调用返回的是true，则自己不用调整，也返回true</p>
<p><em>3：</em>如果调用的remove返回false，则需要返回adjust，一边检查高度是否发生变换+调整，调整后如果高度变化返回false，反之true（具体就是我们讨论的几个调整情况）</p>
<ul>
<li>调整函数（adjust）</li>
</ul>
<p>参数subTree（subtract Tree）1表示删除的右子树，0表示删除的左子树</p>
<p>0则是我们讨论的那五种情况</p>
<p>1则是完全对称的五种情况</p>
<p>调用adjust不一定高度有变化，但是平衡度一点是发生变化了</p>
<pre><code class="CPP">template&lt;class KEY, class OTHER&gt;
bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree)		
&#123;
    if (subTree)													//如果删除的是右子树，逻辑和下面的只是镜面对称
    &#123;
        if (height(t-&gt;left) - height(t-&gt;right) == 1)return true;	
        if (height(t-&gt;right) == height(t-&gt;left))					
        &#123;
            --t-&gt;height; return false;								
        &#125;
        if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left))			
        &#123;
            LR(t);													
            return false;											
        &#125;
        LL(t)														
            if (height(t-&gt;right) == height(t-&gt;left))return false;	
            else return true;									
    &#125;																
    else															//如果删除的是左子树
    &#123;
        if (height(t-&gt;right) - height(t-&gt;left) == 1)return true;	
        //对应（a）删除的左子树，如果是当前平衡度为-1，表示之前的平衡度就是0（如果是-1的话根本不会调用adjust好吧），因为删除是左子树，只有左子树降低高度的可能，（表示根据前面由平衡度判断高度结论判定）当前节点不需要调整+高度也没有发生变化
        if (height(t-&gt;right) == height(t-&gt;left))
        &#123; 
            --t-&gt;height; return false;
        &#125;
        //对应情况（b），根据结论一定是从1到0，高度一定发生变化了，但是平衡度依旧正常，返回false
        if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))
        &#123;
            RL(t);
            return false;
        &#125;
        //对应情况（d），右子节点的左子树的节点的高度大于右子树进行RL
        
        RR(t)
            if (height(t-&gt;right) == height(t-&gt;left))				
                return false;
            else return true;
        //对于（c）和（e）只需要RR（左旋即可），对于这两种情况使用RR后的区别就是（c）调整后平衡度为0，节点高度发生变化return false，对于（e）使用RR，节点应该变为1，但是高度没有发生变化，return true
    &#125;
&#125;
</code></pre>
<hr>
<p>到此难的地方已经处理好了其他的构造析构都是完全继承完全二叉树，所以不再赘述了</p>
<h3 id="有时间再补补性能分析吧"><a href="#有时间再补补性能分析吧" class="headerlink" title="有时间再补补性能分析吧"></a>有时间再补补性能分析吧</h3>
    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
