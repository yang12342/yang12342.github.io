
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title> | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/8
        </span>
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据结构
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #ffa2c4">
                    数据结构
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><ul>
<li>先附上完整的代码</li>
</ul>
<span id="more"></span>

<pre><code class="c++">template &lt;class KEY,class OTHER&gt;
struct SET
&#123;
    KEY key;																		
    OTHER other;																	
&#125;;

template&lt;class KEY,class OTHER&gt;
class dynamicSearchTable
&#123;
public:
    virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0;
    virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0;
    virtual void remove(const KEY&amp; x) = 0;
    virtual ~dynamicSearchTable() &#123;&#125;;
&#125;;

template&lt;class KEY, class OTHER&gt;
class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;
&#123;
private:
    struct BinaryNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        BinaryNode* left;
        BinaryNode* right;
        BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL,
            BinaryNode* rt = NULL):data(thedata),right(rt)&#123;&#125;
    &#125;; 
    BinaryNode* root;
    
public:
    BinarySearchTree();
    ~BinarySearchTree();
    SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const;
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x);
    void remove(const KEY&amp; x);
    
private:
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t);
    void remove(const KEY&amp; x, BinaryNode*&amp; t);
    SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const;
    void makeEmpty(BinaryNode* t);
&#125;;


template&lt;class KEY, class OTHER&gt;
SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const
&#123;
    return find(x, root);
&#125;


template&lt;class KEY, class OTHER&gt;
SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const
&#123;
    if (t == NULL || (t-&gt;data.key == x))				
        return (SET&lt;KEY,OTHER&gt;*)t;										
    if (x &lt; t-&gt;data.key)								
        return find(x.t-&gt;left);							
    else return find(x, right);							
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x)
&#123;
    insert(x, root);
&#125;


template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t)
&#123;
    if (t == NULL)
        t = new BinaryNode(x, NULL, NULL);							
    else if (x.key &lt; t-&gt;data.key)									
        insert(x, t-&gt;left);					
    else if (t-&gt;data.key &lt; x.key)									
        insert(x, t-&gt;right);
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x)
&#123;
    remove(x, root);
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t)
&#123;
    if (t == NULL)return;											
    if (x &lt; t-&gt;data.key)remove(x, t-&gt;left);							
    else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right);
    else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL)					
    &#123;																
        BinaryNode* tmp = t-&gt;right;									
        while (tmp-&gt;left != NULL)tmp = tmp-&gt;left;					
        t-&gt;data = tmp-&gt;data;										
        remove(t-&gt;data.key, t-&gt;right);								
    &#125;
    else
    &#123;
        BinaryNode* oldNode = t;									
        t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right;					
        delete oldNode;												
    &#125;
&#125;

template&lt;class KEY, class OTHER&gt;
BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree()
&#123;
    root = NULL;
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)
&#123;
    if (t == NULL)return;										
    makeEmpty(t-&gt;left);
    makeEmpty(t-&gt;right);
    delete t;
&#125;

template&lt;class KEY, class OTHER&gt;
BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree()
&#123;
    makeEmpty(root);
&#125;

int main()
&#123;
    return 0;
&#125;
</code></pre>
<hr>
<h2 id="前提组成"><a href="#前提组成" class="headerlink" title="前提组成"></a>前提组成</h2><ul>
<li><pre><code class="c++">template &lt;class KEY,class OTHER&gt;
struct SET
&#123;
    KEY key;																		//关键字信息
    OTHER other;																	//和其他信息
&#125;;
</code></pre>
<p>这是基本的数据元素</p>
<p>分别包括<strong>键值</strong>key和<strong>其他值</strong>value（就像字典里面对应的查找关键和词语解释）</p>
</li>
<li><pre><code class="c++">template&lt;class KEY,class OTHER&gt;
class dynamicSearchTable
&#123;
public:
    virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0;						//查找目标元素，返回值为指针
    virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0;						//插入功能
    virtual void remove(const KEY&amp; x) = 0;									//显然是删除功能
    virtual ~dynamicSearchTable() &#123;&#125;;										//析构函数
&#125;;
</code></pre>
<p>这就是二叉查找树的父类<strong>动态查找表</strong>，也可以看作一个模板而已，提供了基础的一个动态查找的基本功能模板</p>
</li>
</ul>
<hr>
<h2 id="动态二叉树"><a href="#动态二叉树" class="headerlink" title="动态二叉树"></a>动态二叉树</h2><ul>
<li>动态二叉树的主体类函数</li>
</ul>
<pre><code class="C++">template&lt;class KEY, class OTHER&gt;
class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;
&#123;
private:
    struct BinaryNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        BinaryNode* left;
        BinaryNode* right;

        BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL,
            BinaryNode* rt = NULL):data(thedata),right(rt)&#123;&#125;
    &#125;; BinaryNode* root;

public:
    BinarySearchTree();										//构造函数
    ~BinarySearchTree();									//析构函数
    SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const;				//查找函数（公有，面向使用者）
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x);					//插入函数（公有，面向使用者）
    void remove(const KEY&amp; x);								//删除函数（公有，面向使用者）
private:
    void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t);		//查找函数（私有，面向公有调用函数）
    void remove(const KEY&amp; x, BinaryNode*&amp; t);					//插入函数（公有，面向公有调用函数）
    SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const;	//删除函数（公有，面向公有调用函数）
    void makeEmpty(BinaryNode* t);								//清空函数
&#125;;
</code></pre>
<p><strong>树的节点分析</strong>：</p>
<pre><code class="c++">struct BinaryNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;								//本体的数据
        BinaryNode* left;									//左子节点的指针
        BinaryNode* right;									//右子节点的指针

        BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL,	//节点的构造函数，可以直接设定三个成员
            BinaryNode* rt = NULL):data(thedata),right(rt)&#123;&#125;
    &#125;; BinaryNode* root;
</code></pre>
<p><strong>注意</strong>：后面经常会用到公有函数调用私有函数，虽然名称一样，但一个面向使用者，私有的面向共有的函数调用内部</p>
<pre><code class="c++">void remove(const KEY&amp; x)								//删除函数（公有，面向使用者）
&#123;
    remove(x,root);										//这里调用的就是私有函数
&#125;
void remove(const KEY&amp; x, BinaryNode*&amp; t);				//这就是私有函数的接口和实现
</code></pre>
<h2 id="接下来分析函数的实现"><a href="#接下来分析函数的实现" class="headerlink" title="接下来分析函数的实现"></a>接下来分析函数的实现</h2><ul>
<li><strong>构造函数</strong></li>
</ul>
<pre><code class="C++">template&lt;class KEY, class OTHER&gt;
BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree()
&#123;
    root = NULL;										//简单初始化了一下根节点
&#125;
</code></pre>
<ul>
<li><strong>makempty</strong></li>
</ul>
<p>主要还是递归循环删除，采用了前序遍历的思想</p>
<pre><code class="c++">template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)
&#123;
    if (t == NULL)return;									//递归终止的条件（删到了空节点）
    makeEmpty(t-&gt;left);										//正常步骤先删左节点，往下递归
    makeEmpty(t-&gt;right);									//再删右节点，往下递归
    delete t;												//删除自己	
&#125;//最后就删除了所给节点和节点的所有子节点
</code></pre>
<p><strong>拓展</strong>：其实最近刷题还看到了一种实现方法就是入队和出队在这里</p>
<p>优点：就是摆脱了递归的对于空间的大量调用，利用循环和队列实现（更多是在链表使用的方法）</p>
<p>其实这是层序遍历的使用方法，只是用这个实现了层序遍历的删除方式</p>
<blockquote>
<pre><code class="C++">**自己拓展的，不是范例的**
Queue&lt;BinaryNode*&gt;  queue;									//存放节点指针的队列

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)
&#123;
queue.enqueue(t);										//先把根节点放入队列
   while(t.isempty())										//终止条件：检查队列是否为空，不空则继续进行
   &#123;
       BinaryNode* t=queue.dequeue();						//出队队列的第一个节点
       if(t-&gt;left!=nullptr)queue.enqueue(t-&gt;left);			//左子节点有就放进队列，没则不处理
       if(t-&gt;right!=nullptr)queue.enqueue(t-&gt;right);		//同理
       delete t;											//然后删除自己
   &#125;
&#125;
</code></pre>
</blockquote>
<ul>
<li><strong>析构函数</strong></li>
</ul>
<pre><code class="C++">template&lt;class KEY, class OTHER&gt;
BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree()
&#123;
    makeEmpty(root);											//就从root开始删除，很简单，不解释了
&#125;
</code></pre>
<ul>
<li><strong>插入函数（insert）</strong></li>
</ul>
<p>从这插入函数观察二叉树的<strong>构成特点</strong>：左子节点小于父节点，右子节点大于父节点（节点不会重复）</p>
<p>这个特点就导致插入的时候有一个<strong>特性</strong>：以这个特点往下寻找插入点必然是<strong>叶节点</strong>，从而使插入特别方便。</p>
<p>函数还是递归实现的函数，逐次往下寻找（二叉树的结构导致如果树高了必然会导致搜索耗费大量的时间，之后会有扁平的处理方法）</p>
<pre><code class="C++">template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x)
&#123;
    insert(x, root);												//表示从根节点往下寻找插入点
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t)
&#123;
    if (t == NULL)
        t = new BinaryNode(x, NULL, NULL);							//若根节点不存在，则直接存进去
    else if (x.key &lt; t-&gt;data.key)									//若小于当前节点则向左递归
        insert(x, t-&gt;left);					
    else if (t-&gt;data.key &lt; x.key)									//大于则向右递归
        insert(x, t-&gt;right);										
                                                                    //等于的情况直接退出不干，二叉树的插入必须是不同
&#125;
</code></pre>
<ul>
<li><strong>查找函数（find）</strong></li>
</ul>
<p>查找函数就是基于二叉树的结构特点建立的，<strong>左小右大</strong></p>
<pre><code class="C++">template&lt;class KEY, class OTHER&gt;
SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const
&#123;
    return find(x, root);
&#125;

template&lt;class KEY, class OTHER&gt;
SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const
&#123;
    if (t == NULL || (t-&gt;data.key == x))				//如果是不存在或者就是当前的节点
        return (SET&lt;KEY,OTHER&gt;*)t;						//找到就返回这个指针,没有的话就是返回空指针
    if (x &lt; t-&gt;data.key)								//如果小于则向左找
        return find(x.t-&gt;left);							
    else return find(x, right);							//大于则向右找
&#125;
</code></pre>
<blockquote>
<p><strong>注意</strong>：有人可能会注意到，t不是BinarNode吗，怎么能强制转换为SET类的指针啊</p>
<pre><code class="C++">return (SET&lt;KEY,OTHER&gt;*)t;
</code></pre>
<p>这里需要解释一下结构体和类的一个特点：</p>
<p>对于类和结构的存贮使从第一个数据成员开始的。</p>
<p>举个例子：对于BinarNode的存储空间第一个就是存放的SET，因为在定义里面是写在第一个的。</p>
<p>从而对于指向BinaryNode存储空间的指针某种意义上也是指向了SET的开头，进而可以进行强制转换</p>
<pre><code class="C++">//树节点的结构体
struct BinaryNode
    &#123;
        SET&lt;KEY, OTHER&gt;data;
        BinaryNode* left;
        BinaryNode* right;

        BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL,
            BinaryNode* rt = NULL):data(thedata),right(rt)&#123;&#125;
    &#125;; BinaryNode* root;
</code></pre>
</blockquote>
<img src="list2.png" style="zoom:75%;" />

<ul>
<li><strong>删除函数（remove）</strong></li>
</ul>
<p><strong>主体思路：</strong></p>
<ul>
<li>删除大体是这个思路为了保证树的结构不变，主要分三种情况</li>
<li>1.如果这个删除节点没有度数为0，很简单删除就好了</li>
<li>2.只有一个子节点，把字节点复制上去，把字节点删除</li>
<li>3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数</li>
<li>其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点）</li>
<li>对于这题我们假设向右子节点寻求最接近的值</li>
</ul>
<p><strong>最关键的是：</strong></p>
<p>首先，替代问题，为了保证稳定性必须要替换一个最接近的节点互换位置，顶替</p>
<p>其次由于结构最接近无非 最近但小于（左节点的最右节点）和最近但大于 （右节点的最左字节点）</p>
<p>这个寻找方法便捷的地方在于必然是叶子节点替换，也易于删除</p>
<pre><code class="C++">//这里的实现主要是最右子节点最左节点（大于且最靠近的树）
template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x)
&#123;
    remove(x, root);
&#125;

template&lt;class KEY, class OTHER&gt;
void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t)
&#123;
    //先找到要删除的节点
    if (t == NULL)return;
    //第一种情况空节点返回

    if (x &lt; t-&gt;data.key)remove(x, t-&gt;left);
    //第二种情况，要删除小于当前节点，往左递归
    
    else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right);
    //第三种情况要找的大于当前节点，往右边递归

    else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL)					
    &#123;																
        BinaryNode* tmp = t-&gt;right;									
        while (tmp-&gt;left != NULL)tmp = tmp-&gt;left;
        //循环找到右子节点的最左节点
        
        t-&gt;data = tmp-&gt;data;
        //替换俩个节点顺序
        remove(t-&gt;data.key, t-&gt;right);
        //删除替换后的叶子节点，结束
    &#125;
    //第四种，找到了当前节点就是要删除的节点，但是左右都有子节点
    
    
    else
    &#123;
        BinaryNode* oldNode = t;																					t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right;
        //如果有一个子节点，t就是直接替换为子节点，然后删除原来的节点，即使没有子节点，t变为空间点也合乎逻辑
        delete oldNode;
    &#125;
    //第五种，找到了要么一个子节点，要么没有

    //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理
&#125;
</code></pre>
<blockquote>
<p><strong>有一点需要注意：</strong></p>
<pre><code class="c++">void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t)
</code></pre>
<p>我们发现节点的参数传递都是引用传递，那是为了方便节点直接替换</p>
<p>例如remove，正是因为引用传递，在层层递归中确保每次传下来的<strong>t</strong>都是确确实实来自于父节点里面直接的左右节点的指针</p>
<p>这样就维持了上下关系，确保修改是有效的</p>
<img src="list1.png" style="zoom:50%;" >
</blockquote>
<p>##总结：至此就分析结束了</p>
<p>（有时间在这里补一个二叉树查找性能的分析）</p>
<div style="text-align:center">
</div>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
