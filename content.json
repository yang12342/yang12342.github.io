{"posts":[{"title":"","text":"AVL树解析（基于查找二叉树（dynamicSearchTree））平衡二叉树：在查找二叉树的基础上要求每个节点左右字节点的高度差不能超过一。 于是对于节点多了一个数据成员高度来实现这一功能。 先附上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;dynamicSearchTable.h&quot;template &lt;class KEY, class OTHER&gt;struct SET{ KEY key; //关键字信息 OTHER other; //和其他信息};template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x);private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); bool remove(const KEY&amp; x, AvlNode*&amp; t); void makeEmpty(AvlNode* t); int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} void LL(AvlNode*&amp; t); void LR(AvlNode*&amp; t); void RL(AvlNode*&amp; t); void RR(AvlNode*&amp; t); int max(int a, int b) { return (a &gt; b) ? a : b;} bool adjust(AvlNode*&amp; t, int subTree);};template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) { if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; else return (SET&lt;KEY, OTHER&gt;*)t; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;left; t-&gt;left = t1-&gt;right; t1-&gt;right = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); LL(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) { insert(x, t-&gt;left); if (height(t-&gt;left) - height(t-&gt;right) == 2) if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); else LR(t); } else if (t-&gt;data.key &lt; x.key) { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;}template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; if (x == t-&gt;data.key) { if (t-&gt;left == NULL || t-&gt;right == NULL) { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; return false; } else { AvlNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; if (remove(tmp-&gt;data.key, t-&gt;right))return true; return adjust(t, 1); } } if (x &lt; t-&gt;data.key) { if (remove(x, x-&gt;left))return true; return adjust(t, 0); } else { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } RR(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; }}template&lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::makeEmpty(AvlNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;} 基本组成成员 AvlNode（AVL的树节点） 12345678910struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; //节点的高度 AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h=1):data(element),left(lt),right(rt),height(h){} }; 多了一个高度，构造函数默认为1（指只有自己） 根节点 1AvNodee* root; AVL类的基本数据成员和函数12345678910111213141516171819202122232425262728293031template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数 void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有） void remove(const KEY&amp; x); //删除函数（公有）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); //插入函数（私有） bool remove(const KEY&amp; x, AvlNode*&amp; t); //删除函数（私有） void makeEmpty(AvlNode* t); //清空 int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} //计算当前节点的高度 void LL(AvlNode*&amp; t); //单旋转LL void LR(AvlNode*&amp; t); //双旋转LR void RL(AvlNode*&amp; t); //双旋转RL void RR(AvlNode*&amp; t); //单旋转RR int max(int a, int b) { return (a &gt; b) ? a : b;} //比较函数 bool adjust(AvlNode*&amp; t, int subTree); //调整节点的结构使其平衡的函数}; 其实private类的函数都是公有类函数的工具函数 函数的实现分析 查找函数（find） 123456789101112template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) //循环停止的条件，就是当前节点为空或者就是要找的 { //小于就换成左节点，反之换成右节点， if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; //空就返回 else return (SET&lt;KEY, OTHER&gt;*)t; //这里还是强制转换} 还是基于二叉查找树的特性，只是没有使用递归函数，这种方式被称为迭代实现 插入函数（insert） 在介绍函数之前理解一些东西，关于插入的一些特性： 1. 首先插入还是和二叉查找树一样插入在叶子节点上 2. 一次插入后，只有在插入点到根的路径上的节点才有可能发生平衡度的变化 3. AVL的平衡策略最多只要调整一个节点就可以了 主要分析LL和LR俩种情况注意： 对于旋转策略的核心是保证节点的高度不发生变化，就是通过旋转变为原来的高度，从而保证对上面节点安全的保证。 一旦改变了数的高度，那需要不断往上检索，直到那个节点的高度没有发生变化 LL：原来A的左子树比右子树高，插入发生在A的左儿子的左子树中，使A的左子树增高 (注意（仅仅对于插入而言，对于删除这个结论反而相反）：平衡度只是一种高度是否平衡的表现形式，真正影响的是节点的高度，主要体现在平衡度向零趋近高度不变，而向俩边增长表明节点高度发生改变) 此图有图 节点平衡度从-1到0但是并不影响上面的节点，因为这个节点的高度并未发生改变，反而0到1表明当前节点的高度发生改变 现在来分析LL的情况此处有图 首先分析一下一些情况： 1. **首先B的平衡度一定原来是0，然后变为1， 因为我们上面解释过如果是-1到0表明是向零趋近，B的高度不会发生变化，进而不会影响A 若是原来是1，变成2，显然B才是危机节点，处理就不是A了 对于LL解决办法就是向右旋转 此处有图 显然我们发现在旋转后我们发现我们处理的这个树的高度与插入前的高度完全一样，于是不用担心上面节点的平衡度了 思考： 对于这种旋转必然是左右子树未实现满二叉树或者完全二叉树导致，就是有空缺的位置来保证旋转后高度不发生变化 那么假设是满二叉树插入，我们会发现并不影响平衡度都从（0到1或者0到-1） （其实这就是插入点后的检索过程，虽然高度发生了变化，但是一直向上检索发现平衡度没有打破规则，那么就会检索到根节点结束） 现在附上LL代码图 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) //注意这里传的是原来的指针，估计是父节点的指针，不然改了没意义 A{ AvlNode* t1 = t-&gt;left; //失衡的A，先标记B点为t1（A的左子节点） t-&gt;left = t1-&gt;right; //B的右子树，变成A的左子树 t1-&gt;right = t; //B的右子节点变成A t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //此时更新各自的高度（+1是为了包括本身） t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; //将t彻底变为B点（B成为t的指向点）} 有心情的话 可以在这个补一个过程图，看我以后记不记的住吧 *1.*我们发现指针还是引用传递，主要是我要旋转A点，那么就需要修改A的父节点对应的指针从。原理和二叉查找树的原理相同 RR也是同理只是向左旋转附上RR的代码 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) //这个和上面是一个道理，就是向左转，就像镜像一样{ AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;} 现在来分析LR的情况为什么要单独讨论这种情况？因为我们发现仅仅如果使用LL右旋发现只是不过对这个树镜像对称过去了而已，A点仍然是失衡点，只不过是现在是右子树高了 此处有图 我们相对于之前多了一个参考C节点，对于CL和CR谁的高度为h-1并不重要 为了保证根节点的高度不发生变化，我们选择LR的双旋转的方法，对B点进行左旋转（RR），再对A点进行右旋转（LL） 不难发现，C点占据了原来的根节点，且平衡度恢复了0，因为是1到0我们便可认定节点的高度没有发生变化，从而无需再向上检索 过程如下图显示 其实逻辑也很好理解就是让根节点的右边多一个高度来平衡多的那个节点 代码如下 123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); //先对B进行左旋 LL(t); //再对A点进行右旋} RL也完全是同理，就是对称了一下123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);} 以上我们分析了四种旋转情况接下来就来分析插入函数前面我们提到了一个关键词回溯 对于代码里面的回溯就是在修改后往回检查，最好想的就是树了，我修改了叶节点，我需要对查找路径上的每一个点进行检查，那么我们在代码中如何往回实现这个功能呢？ 答案就是利用 递归 假如我们要进行修改，并检查，可以用如下伪代码实现 12345678910插入函数{检查当前节点是不是插入点，是就插入不是就根据于当前节点的大小调用“函数（左节点）/函数（右节点）”//因为是递归调用，执行到这一样表示递归所有的修改已完成开始回溯了检查当前节点的平衡度来看是否需要调整，若失衡分类讨论重新计算高度} 附上代码 其实我们发现这个回溯必须全部走完，因为要更改高度（尤其是满二叉树那种虽然不影响平衡度，但是路径上所有节点高度都需要+1） 1234567891011121314151617181920212223242526272829303132template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) //情况1：如果根节点为空就直接放置 t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) //情况2：如果比当前节点小，往左子树插入 { insert(x, t-&gt;left); //向下递归 if (height(t-&gt;left) - height(t-&gt;right) == 2) //执行到这一步表示左子树全部节点都平衡了，检查自己了 if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); //当前节点失衡了，只要判断插入节点是在左子节点的左右 //就可以判断是哪种情况 else LR(t); } else if (t-&gt;data.key &lt; x.key) //这里的逻辑是一样的，参照上面就行了 { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //在最后插入好，会从底往上重新计算树的高度} 删除函数（remove） 删除节点很有可能导致树变矮，导致二叉树失衡，所以必须要在删除后不断回溯调整平衡 首先这是一个回溯的过程，还有一个关键点就是是否需要再网上回溯的关键是: 的当前节点的高度在调整后或者未调整高度是否发生变换，注意我说的是高度不是平衡度，若往回检索发现有节点高度未发生变化就可以停止检查调整步骤直接return。 这也表明了虽然删除是递归，但是返回值是一个bool表示当前节点高度是否发生变化从而决定上面的节点是否需要检查 删除过程这一个和二叉查找树没什么区别其实，依旧是分为三种情况（无儿子，一个儿子，俩个儿子） 前俩个可以用一个表达式来代替 1t=（t-&gt;left!=NULL）:t-&gt;left?t-right; 相对后面的情况显示是迭代找到可替换的叶子节点，然后删除叶子节点啦。 检查过程删除的时候没有插入那么幸运，删除时的调整很有可能导致整棵树高度下降，从而影响路上的所有父节点。 停止条件：只有当某个节点读的高度在删除后不变才无需向上检查调整了 导致树的高度发生变化有以下几种情况 （注意：这里平衡度是在向两边增长节点高度不变，向零靠近节点高度发生变化，因为是删除 （与插入的结论恰恰相反，插入是有可能增高，而删除是有可能降低高度）） 此处有五种情况（假设都是在左子树上删除的节点） 此处有图 对于（a）的平衡度既没有失衡，高度也没有发生变化 对于（b）平衡度没有失衡，但是根据平衡度的变化可以发现节点的高度发生变换，需要检查父节点 对于（c）只需要节点P使用左旋（RR）即可，这样根节点的高度就变成了0，虽然平衡了但是平衡度从-1变为0，节点高度发生变化，需要检查父节点 对于（d）显然左旋仍然导致失衡，就像前面的RL的情况一样发生在内侧，这个时候就需要先对P的右子节点先右旋（LL）再对P进行左旋（RR），就会使根节点平衡度变为0.不需要对父节点进行检查 对于（e）对P使用简单的左旋（RR）根节点（原来P的位置）的平衡度变为1（注意平衡度从-1到1，节点的高度并未发生变化，可以认为就像交换了一样）；当然可以使用RL，这样的话根节点的平衡度仍为-1，高度未发生变化。所以俩种方法都不需要检查父节点 对于添加在右子节点的方法对称就好了 附上代码 （指针参数还是引用，原因上面解释过了） （true表示不用检查，false表示节点的高度发生变化，需要检查节点的高度） 删除函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; //空树不存在，不用检查父节点 if (x == t-&gt;data.key) //情况1：如果是当前节点 { if (t-&gt;left == NULL || t-&gt;right == NULL) //删除情况1，2：如果只是有一个子节点或者没有节点 { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; //因为对只有一个节点或者无叶节点的删除必然导致高度变换，肯定是 return false; //要检查的 } else { AvlNode* tmp = t-&gt;right; //删除情况三：有俩个子节点 while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //迭代找到右子树的最左子节点 t-&gt;data = tmp-&gt;data; //数据替换 if (remove(tmp-&gt;data.key, t-&gt;right)) //然后就是删除的目标换成最新的叶节点，从当前的节点右节点开始 return true; //如果这个删除最后返回的是true，表明右子节点的高度未变化 return adjust(t, 1); //1表示删除在右子树上，t表示当前节点失衡，需要调整 } } if (x &lt; t-&gt;data.key) //情况2：小于则是向左找 { if (remove(x, x-&gt;left))return true; //向左递归 return adjust(t, 0); //如果需要检查，则调用adjust，0表示删除的是左子树 } else //情况三：大于则是向右找 { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }} 这段逻辑其实挺绕人的，remove函数的返回值主要三种： 1：删除的是只有一个字节点或者无子节点（直接返回true，必然改变高度） 2：向下递归调用remove，如果调用返回的是true，则自己不用调整，也返回true 3：如果调用的remove返回false，则需要返回adjust，一边检查高度是否发生变换+调整，调整后如果高度变化返回false，反之true（具体就是我们讨论的几个调整情况） 调整函数（adjust） 参数subTree（subtract Tree）1表示删除的右子树，0表示删除的左子树 0则是我们讨论的那五种情况 1则是完全对称的五种情况 调用adjust不一定高度有变化，但是平衡度一点是发生变化了 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) //如果删除的是右子树，逻辑和下面的只是镜面对称 { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else //如果删除的是左子树 { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; //对应（a）删除的左子树，如果是当前平衡度为-1，表示之前的平衡度就是0（如果是-1的话根本不会调用adjust好吧），因为删除是左子树，只有左子树降低高度的可能，（表示根据前面由平衡度判断高度结论判定）当前节点不需要调整+高度也没有发生变化 if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } //对应情况（b），根据结论一定是从1到0，高度一定发生变化了，但是平衡度依旧正常，返回false if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } //对应情况（d），右子节点的左子树的节点的高度大于右子树进行RL RR(t) if (height(t-&gt;right) == height(t-&gt;left)) return false; else return true; //对于（c）和（e）只需要RR（左旋即可），对于这两种情况使用RR后的区别就是（c）调整后平衡度为0，节点高度发生变化return false，对于（e）使用RR，节点应该变为1，但是高度没有发生变化，return true }} 到此难的地方已经处理好了其他的构造析构都是完全继承完全二叉树，所以不再赘述了 有时间再补补性能分析吧","link":"/2024/06/09/AVL/"},{"title":"","text":"二叉查找树 先附上完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133template &lt;class KEY,class OTHER&gt;struct SET{ KEY key; OTHER other; };template&lt;class KEY,class OTHER&gt;class dynamicSearchTable{public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; virtual void remove(const KEY&amp; x) = 0; virtual ~dynamicSearchTable() {};};template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; public: BinarySearchTree(); ~BinarySearchTree(); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x); private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); void remove(const KEY&amp; x, BinaryNode*&amp; t); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; void makeEmpty(BinaryNode* t);};template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) return (SET&lt;KEY,OTHER&gt;*)t; if (x &lt; t-&gt;data.key) return find(x.t-&gt;left); else return find(x, right); }template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) insert(x, t-&gt;right);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ if (t == NULL)return; if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; remove(t-&gt;data.key, t-&gt;right); } else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; }}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL;}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root);}int main(){ return 0;} 前提组成 template &lt;class KEY,class OTHER&gt; struct SET { KEY key; //关键字信息 OTHER other; //和其他信息 }; 123456789101112131415 这是基本的数据元素 分别包括**键值**key和**其他值**value（就像字典里面对应的查找关键和词语解释）- ~~~c++ template&lt;class KEY,class OTHER&gt; class dynamicSearchTable { public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; //查找目标元素，返回值为指针 virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; //插入功能 virtual void remove(const KEY&amp; x) = 0; //显然是删除功能 virtual ~dynamicSearchTable() {}; //析构函数 }; 这就是二叉查找树的父类**动态查找表**，也可以看作一个模板而已，提供了基础的一个动态查找的基本功能模板 动态二叉树 动态二叉树的主体类函数 1234567891011121314151617181920212223242526template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root;public: BinarySearchTree(); //构造函数 ~BinarySearchTree(); //析构函数 SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数（公有，面向使用者） void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有，面向使用者） void remove(const KEY&amp; x); //删除函数（公有，面向使用者）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); //查找函数（私有，面向公有调用函数） void remove(const KEY&amp; x, BinaryNode*&amp; t); //插入函数（公有，面向公有调用函数） SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; //删除函数（公有，面向公有调用函数） void makeEmpty(BinaryNode* t); //清空函数}; 树的节点分析： 123456789struct BinaryNode { SET&lt;KEY, OTHER&gt;data; //本体的数据 BinaryNode* left; //左子节点的指针 BinaryNode* right; //右子节点的指针 BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, //节点的构造函数，可以直接设定三个成员 BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 注意：后面经常会用到公有函数调用私有函数，虽然名称一样，但一个面向使用者，私有的面向共有的函数调用内部 12345void remove(const KEY&amp; x) //删除函数（公有，面向使用者）{ remove(x,root); //这里调用的就是私有函数}void remove(const KEY&amp; x, BinaryNode*&amp; t); //这就是私有函数的接口和实现 接下来分析函数的实现 构造函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL; //简单初始化了一下根节点} makempty 主要还是递归循环删除，采用了前序遍历的思想 12345678template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; //递归终止的条件（删到了空节点） makeEmpty(t-&gt;left); //正常步骤先删左节点，往下递归 makeEmpty(t-&gt;right); //再删右节点，往下递归 delete t; //删除自己 }//最后就删除了所给节点和节点的所有子节点 拓展：其实最近刷题还看到了一种实现方法就是入队和出队在这里 优点：就是摆脱了递归的对于空间的大量调用，利用循环和队列实现（更多是在链表使用的方法） 其实这是层序遍历的使用方法，只是用这个实现了层序遍历的删除方式 123456789101112131415&gt;**自己拓展的，不是范例的**&gt;Queue&lt;BinaryNode*&gt; queue; //存放节点指针的队列&gt;template&lt;class KEY, class OTHER&gt;&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)&gt;{queue.enqueue(t); //先把根节点放入队列 while(t.isempty()) //终止条件：检查队列是否为空，不空则继续进行 { BinaryNode* t=queue.dequeue(); //出队队列的第一个节点 if(t-&gt;left!=nullptr)queue.enqueue(t-&gt;left); //左子节点有就放进队列，没则不处理 if(t-&gt;right!=nullptr)queue.enqueue(t-&gt;right); //同理 delete t; //然后删除自己 }&gt;} 析构函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root); //就从root开始删除，很简单，不解释了} 插入函数（insert） 从这插入函数观察二叉树的构成特点：左子节点小于父节点，右子节点大于父节点（节点不会重复） 这个特点就导致插入的时候有一个特性：以这个特点往下寻找插入点必然是叶节点，从而使插入特别方便。 函数还是递归实现的函数，逐次往下寻找（二叉树的结构导致如果树高了必然会导致搜索耗费大量的时间，之后会有扁平的处理方法） 1234567891011121314151617template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root); //表示从根节点往下寻找插入点}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); //若根节点不存在，则直接存进去 else if (x.key &lt; t-&gt;data.key) //若小于当前节点则向左递归 insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) //大于则向右递归 insert(x, t-&gt;right); //等于的情况直接退出不干，二叉树的插入必须是不同} 查找函数（find） 查找函数就是基于二叉树的结构特点建立的，左小右大 123456789101112131415template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) //如果是不存在或者就是当前的节点 return (SET&lt;KEY,OTHER&gt;*)t; //找到就返回这个指针,没有的话就是返回空指针 if (x &lt; t-&gt;data.key) //如果小于则向左找 return find(x.t-&gt;left); else return find(x, right); //大于则向右找} 注意：有人可能会注意到，t不是BinarNode吗，怎么能强制转换为SET类的指针啊 1return (SET&lt;KEY,OTHER&gt;*)t; 这里需要解释一下结构体和类的一个特点： 对于类和结构的存贮使从第一个数据成员开始的。 举个例子：对于BinarNode的存储空间第一个就是存放的SET，因为在定义里面是写在第一个的。 从而对于指向BinaryNode存储空间的指针某种意义上也是指向了SET的开头，进而可以进行强制转换 12345678910//树节点的结构体struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 删除函数（remove） 主体思路： 删除大体是这个思路为了保证树的结构不变，主要分三种情况 1.如果这个删除节点没有度数为0，很简单删除就好了 2.只有一个子节点，把字节点复制上去，把字节点删除 3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数 其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点） 对于这题我们假设向右子节点寻求最接近的值 最关键的是： 首先，替代问题，为了保证稳定性必须要替换一个最接近的节点互换位置，顶替 其次由于结构最接近无非 最近但小于（左节点的最右节点）和最近但大于 （右节点的最左字节点） 这个寻找方法便捷的地方在于必然是叶子节点替换，也易于删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445//这里的实现主要是最右子节点最左节点（大于且最靠近的树）template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ //先找到要删除的节点 if (t == NULL)return; //第一种情况空节点返回 if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); //第二种情况，要删除小于当前节点，往左递归 else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); //第三种情况要找的大于当前节点，往右边递归 else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //循环找到右子节点的最左节点 t-&gt;data = tmp-&gt;data; //替换俩个节点顺序 remove(t-&gt;data.key, t-&gt;right); //删除替换后的叶子节点，结束 } //第四种，找到了当前节点就是要删除的节点，但是左右都有子节点 else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; //如果有一个子节点，t就是直接替换为子节点，然后删除原来的节点，即使没有子节点，t变为空间点也合乎逻辑 delete oldNode; } //第五种，找到了要么一个子节点，要么没有 //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理} 有一点需要注意： 1&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t) 我们发现节点的参数传递都是引用传递，那是为了方便节点直接替换 例如remove，正是因为引用传递，在层层递归中确保每次传下来的t都是确确实实来自于父节点里面直接的左右节点的指针 这样就维持了上下关系，确保修改是有效的 ##总结：至此就分析结束了 （有时间在这里补一个二叉树查找性能的分析）","link":"/2024/06/08/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8dynamicSearchTree%EF%BC%89/"},{"title":"奥日与萤火森林2","text":"玩奥日有感（真随笔）剧情上 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图解锁了地底下和森林的碎片唤醒了底下的蜘蛛（被腐朽吞噬了心智）夸洛克牺牲了自我换回碎片 剧情就不得不提到npc了莫基——路人角色，大大小小的任务都有承担，森林的原住民算是库克——地图提供者猴子——推动剧情，教会武器方面技能商人——交易升级技能夸洛克——沼泽的庇护神工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器 玩法上在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。在角色系统我会介绍这些对玩法的贡献 主要是——场景，场景关卡设置，物品和玩法剖析 场景的关卡前期的最大关卡就是【1】找到散落的楔石打开石门小的关卡【2】拖拽石头来阻挡机关和帮助跳跃还有类似司机挡位的机关——触发一些机关，打开石门等等【3】还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏 场景物品藤条——帮助跳跃竖直木棒——陷阱悬停水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了羽毛——还有库和奥日的配合玩法—— 补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯 玩法其实有的已经融合在以上或者以下的分析里面主要探索，打斗剧情的玩法——对话打斗boss等boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣 场景第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景 从角色系统上分析主要分为四个部分 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条） 武器+主动技能系统从光剑到弓箭到重锤，技能则有光之箭和回血等评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。光剑——可以打碎一些木板障碍物例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速重锤——可以打碎石板光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）其他目前武器目前没有看到对地图探索的作用，有再补充 不可见的被动技能例如二连跳抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深 课拆卸购买升级的被动技能首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级技能框则是探索地图一步一步的去扩展讲几个印象比较深的技能:攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行三连跳——好吧也是默认了，不仅帅而且探索地图确实方便其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧 （4）","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%A3%AE%E6%9E%97%E4%BD%93%E4%BC%9A/"},{"title":"欢迎来到我的博客，见证我的成长","text":"在此特别感谢voidMatrix老师和从零开始的C++游戏开发的群友的帮忙！！ 希望群友们能够在今后的日子里互相帮助互相进步，也祝V老师事业蒸蒸日上！！","link":"/2024/06/03/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%A7%81%E8%AF%81%E6%88%91%E7%9A%84%E6%88%90%E9%95%BF/"},{"title":"笼中窥梦","text":"笼中窥梦心得第一次玩到这个游戏我就想到了初中玩的画中世界，视觉错觉的艺术美与打动人心且朦胧的故事感，很平静却又是如此吸引人。感觉就像是在品味人生，同时享受着美妙的艺术。 从叙事性上看吧，这类的游戏没有明确表述主线，都是以一种很朦胧大概的方式，只言片语的描绘故事，这就像一千个读者一千个哈姆雷特，我觉得这种叙事方式却给了玩家最好的体验。叙事主要是从游戏的场景，拾起的相片，和游戏交互推动的。从我第一次简单通关的角度描绘我眼中的故事：大体上是简单的讲述了一个人的一生，从小然后成长为一位研制武器的科学家，颇有成果但是在战乱后他同样参军，流离失所，于硝烟中漂泊，见识到了他的武器在战争中给无数人带来的苦难，一路走来，他见证了多少美好的过去被战火所毁灭，春去秋来，撑到了战争结束的一天，但是他却孑然一身，陷入了深深的自责与内疚，他走不出这段阴影，更对不起过去小时候的自己，看到无数因为战争而生出的坟墓，时常到教堂去忏悔自己罪恶（这个教堂是当时的一个场景，经理三个阶段，战争前，被毁灭，被重建，也许也暗示主线的过程）。但是在一步步中他慢慢打开了心结，离开了医院，回到了过去的小屋接纳当下的自己。最让我印象深刻的场景就是最后，过去小时候的照片中的自己与今天的自己被拼接在一起，俩个人面面相觑，但最后成长的自己将小时候的自己紧紧抱入了怀中，说真的那个时候真的很感人。最后的最后，场景再次回到了游戏开始的时候。怎么说呢，笼中窥梦，确实在一个一个个镜面里窥看一个人的一生，也许是梦，也许是一个人的故事，而且视觉错位的艺术玩法和诗意平静的叙事方式真的很打动人吧，最后回到故事的开始，是梦醒，更让我感受到这个游戏就像梦一样。人的一生坎坎坷坷，跌跌撞撞，最美好的故事的结局还是走到故事的起点吗？ 游戏的场景上，每一个场景都蕴含了主角故事的较为关键的节点，同时一些场景也在隐喻着一些事情，举个例子其中一个场景是启动导弹的发射，于是故事的叙事开始从战争的角度开始描述，还有前面的教堂的变换贯穿了战争和战后，从长满杂草到被战火摧残再到重建成为人们心里的寄托，也许反应主人公的心境吧。 在玩法上，确实很有创新，利用场景的拼接去描述一个一个故事。难度上不是很大，高亮是当下要用的，浅亮的重要但是不是当下用，而且可以选择提示和演示视频（我中间确实有几次卡关了），一方面是可利用的游戏场景他不会标记，你可能想不到，另一方面有的交互是一连串触发有时间的限制，影响最深的就是一个炮弹滚了大概三四个场景才完成最终的目的，但整体看下来不是很难，有些地方有小彩蛋来解锁成就。虽难脑袋不是很适合解密，但是视觉错觉的艺术玩法和平静诗意的叙事很触动我，也许是生活缺少了感动（我承认我情商确实低…….）在音乐上，额，几乎没有背景音乐，只有互动场景的音效，我觉得是不是可以配上一点适合氛围的音乐（虽然只有俩个人做出来确实不容易），但是当下这个作品已经近乎完美了。 漫谈 ：提到游戏，我更加喜欢像这样叙事朦胧却又真的打动人心，仅仅通过场景去体会这种故事。我玩的游戏不多，但是像这样印象深刻就是画中世界和地狱边境。画中世界的故事梗概记不住了，美术相当出色，解密做的也很好，地狱边境的内容比较清楚，好像是描述一家人遭遇了车祸，然后弟弟在地狱只有黑白的场景一路寻找他的姐姐，相较于这个游戏那个故事更有起伏，因为有怪物的存在，但是最后他终于姐姐相会了（也许是俩个人最后都离开了），同样有姐姐的我当时也是印象深刻，生离死别，却又在最后看见了你最后一眼，真的是。。。。 最后说一说笼中窥梦的作者，感兴趣的可以上b站搜《钱从哪来》的栏目，有一期就采访了他们的团队，俩个人，一个程序策划，一个美术，打磨出了这个作品。独立游戏制作的不易，可以从这个节目看到。有一期还是采访了我们学校的一个团队，放弃读研，放弃offer，几个人出来做游戏，可是才发现做独立游戏的道路上确实更多窘境和不易——《成土市的我》《什么鸟都》 看到一个朋友圈是“珍惜身边做独游的人吧，非要说的话那就是爱。” 最后用笼中窥梦的作者的话，“祝愿你做一个好梦”","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E7%AC%BC%E4%B8%AD%E7%AA%A5%E6%A2%A6%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"游戏心得","slug":"游戏心得","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"}],"categories":[{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"游戏心得","slug":"游戏心得","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"}],"pages":[]}