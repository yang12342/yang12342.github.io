{"posts":[{"title":"","text":"类的继承 在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。 那今天就好好看看关于继承方面要注意的语法点 派生类的定义123456789class 派生类名：继承方式 基类名{ 新增加的成员定义；}class student: public people{ }; 唯一要说明的其实就是继承方式 public public（公有类）指的是对应的成员变量和函数可以被外界（全局函数，其他类的成员函数），自己的成员函数和友元直接调用 最直观的就是被外界调用（前提是这些在类内是public） 1234student 小明； 小明.height(); //函数返回 小明。height； //直接返回成员变量//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量 private private（私有类）就是仅仅只限于类内的成员函数和友元进行访问 protected protected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数 但是基类的成员函数和成员变量的访问特性也会随着继承方式变化 基于成员的访问特性 public继承 protected继承 private继承 public public protected private private 不可访问 不可访问 不可访问 protected protected protected private 其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性 我们只需要关注继承过来的变量对于当前类的访问特性。 123456789101112131415161718class base{private: int a;public: void deal();};class base1:protected base{ //这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用 //public继承过来则是protected类，说明可以继续往下继承};class base2:protected base1{ //这个也是完全能调用deal}; 其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用 派生类对象的构造和析构 好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。 因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要 但还是得了解不是吗？ 继承的构造和析构其实也很好理解 对于子类的构造，优先级是这样的 基类的构造函数 自己里面包含的其他类的构造函数 然后是自己的构造函数 派生类的构造函数形式如下 1234student(int a,int b):people(a){ //在：后面给对应的基类传去对应的参数就行} 注意：派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决 析构函数的顺序则是相反 先执行自己的析构函数 再解决基类的析构函数 重定义基类的函数当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖 123456789101112131415161718192021class base{public: int deal(){}}class base1:public base{public: int deal(){}}//此时调用base1.deal则是用派生类定义的deal//如果需要调用父类的那个函数class base{public: int deal() { base:deal(); //需要“基类名：函数名”来调用父类的重定义的函数 }} 将派生类对象隐式转换为基类对象1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员 1base=base1； 2.基类指针指向派生类（很重要） 在植物明星大乱斗中，我们都是通过基类指针指向派生的对象 player指针指向豌豆和向日葵，scene指向不同的场景 基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。 因此指向派生类的基类指针出发，只能访问派生类中的基类成员。 1234567891011121314class base{public: void deal() { }};class base1:public base{ void play();}base* point=new base;point-&gt;deal(); //这是可以的point-&gt;play(); //这是不行的 注意：虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展 但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？ Q&amp;A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量 3.基类对象引用派生类的对象 引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分 1base &amp;point=new base1; 这样对基类引用的访问其实就是对派生类的基类的访问 注意： 派生类的指针不能指向基类 派生类的指针也不能接受基类的指针 123base1 d,*dp;base *bp=dp; //基类指针指向派生类，正确的dp=bp; //但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的 如果强制要转,使用强制类型转换（明确不会犯错） 1dp=reinterpret_cast&lt;Derived*&gt; bp; 最后附上一段植物明星大乱斗子弹类的继承（删了一些）基类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#ifndef _BULLET_H_#define _BULLET_H_#include &quot;vector2.h&quot;#include &quot;player_id.h&quot;#include &quot;camera.h&quot;#include &lt;graphics.h&gt;#include &lt;functional&gt;extern bool is_debug;class Bullet{public: Bullet() = default; ~Bullet() = default; void set_callback(std::function&lt;void()&gt; callback) { this-&gt;callback = callback; } void set_valid(bool flag) { valid = flag; } bool get_valid()const { return valid; } bool check_can_remove()const { return can_remove; } virtual void on_collide() { if (callback) callback(); } virtual bool check_collision(const Vector2&amp; position, const Vector2&amp; size) { return this-&gt;position.x + this-&gt;size.x / 2 &gt;= position.x &amp;&amp; this-&gt;position.x + this-&gt;size.x / 2 &lt;= position.x + size.x &amp;&amp; this-&gt;position.y + this-&gt;size.y / 2 &gt;= position.y &amp;&amp; this-&gt;position.y + this-&gt;size.y / 2 &lt;= position.y + size.y; } virtual void on_update(int delta){} virtual void on_draw(const Camera&amp; camera)const { if (is_debug) { setfillcolor(RGB(255, 255, 255)); setlinecolor(RGB(255, 255, 255)); rectangle((int)position.x, (int)position.y, (int)position.x + size.x, (int)position.y + size.y); solidcircle((int)(position.x + size.x / 2), (int)(position.y + size.y / 2), 5); } }protected: //为了方便子类可以直接读取数据，所以选择protected Vector2 size; //子弹尺寸 Vector2 position; //子弹位置 Vector2 velocity; //子弹速度 int damage = 10; //子弹伤害 bool valid = true; //子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画 bool can_remove = false; //子弹是否可以被移除 std::function&lt;void()&gt; callback; //子弹碰撞回调函数，因为子弹可以积攒玩家的能量 PlayerID target_id = PlayerID::P1; //子弹碰撞目标玩家ID，以免自己打自己protected: bool check_if_exceeds_screen() { return (position.x + size.x &lt;= 0 || position.x &gt;= getwidth() || position.y + size.y &lt;= 0 || position.y &gt;= getheight()); }};#endif // !_BULLET_H_ 派生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#ifndef _PEA_BULLET_H_#define _PEA_BULLET_H_#include &quot;bullet.h&quot;#include &quot;animation.h&quot;extern IMAGE img_pea;extern Atlas atlas_pea_break;class PeaBullet :public Bullet{public: PeaBullet() { size.x = 64; size.y = 64; damage = 10; animation_break.set_atlas(&amp;atlas_pea_break); animation_break.set_interval(100); animation_break.set_loop(false); animation_break.set_callback([&amp;]() {can_remove = true; }); } ~PeaBullet() = default; void on_collide() { Bullet::on_collide(); switch (rand() % 3) { case 0: mciSendString(_T(&quot;play pea_break_1 from 0&quot;), NULL, 0, NULL); break; case 1: mciSendString(_T(&quot;play pea_break_2 from 0&quot;), NULL, 0, NULL); break; case 2: mciSendString(_T(&quot;play pea_break_3 from 0&quot;), NULL, 0, NULL); break; } } void on_update(int delta) { position += velocity * (float)delta; if (!valid) animation_break.on_updata(delta); if (check_if_exceeds_screen()) can_remove = true; } void on_draw(const Camera&amp; camera)const { if (valid) putimage_alpha(camera, (int)position.x, (int)position.y, &amp;img_pea); else animation_break.on_draw(camera, (int)position.x, (int)position.y); Bullet::on_draw(camera); }private: Animation animation_break; };#endif // !_PEA_BULLET_H_","link":"/articles/c++%E8%AF%AD%E6%B3%95/%E7%BB%A7%E6%89%BF/"},{"title":"c++输入输出","text":"c++输入输出 学校对于这一节并没有教，当时看也只是模仿了上面的案例，不是很懂。现在在VoidMatrix的塔防教程中看到了这方面知识点相关，就想相对了解一下 12345678std::fstream file(path); if (!file.good())return false;std::stringstream str_stream; str_stream &lt;&lt; file.rdbuf(); file.close(); cJSON* json_root = cJSON_Parse(str_stream.str().c_str()); 主要弄明白这一段代码的意思。 C++的输入输出主要分为三大类： 基于控制台的输入和输出：从标准的输入设备（键盘）获得数据，把程序的执行结果输出到标准的输出设备（显示器） 基于文件的输入和输出：从外储存器文件获取数据或把数据存入外储存器的文件 基于字符串的输入和输出：从程序string类型的变量获取数据或把数据存于string类型的变量 这些输入和输出都是由c++标准库提供的。 流与标准库输入流：输入操作中，字节从设备流向内存 输出流：输出操作中，字节从内存流向设备 C++的输入输出类主要包含在三个头文件中（注意输入输出是一个类，是一个可以实例化的对象） iostream：基于控制台的输入和输出 fstream：基于文件的输入和输出 sstream：基于字符串的输入和输出 输入输出标准库及其头文件类型 iostream（头文件） istream:控制台输入流类，他的对象代表一个输入设备 ostream:控制台输出流类，他的对象代表一个输出设备 iostream:控制台输入输出流类，他的对象代表一个输入或输出设备，这个类是由istream和ostream共同派生 fstream（头文件） ifstream:输入文件流类，他的对象代表一个输入文件，由istream派生而来 ofstream:输出文件流类，他的对象代表一个输出文件，由ostream派生而来 fstream:输入输出文件流类，他的对象代表一个输入或输出文件，这个类是由iostream共同派生 sstream（头文件） istringstream:输入字符串类，由istream派生而来 ostringstrea:输出字符串类，由ostream派生而来 stringstream:输入输出字符串类，由iostream派生而来 输入和输出缓冲程序只能访问内存中的信息，而不能访问外部设备中的信息。 所以外部设备的信息会先存入内存再被程序访问，程序的输出也同样会放在内存再流向外部设备 内存中存放这些数据的区域被称为输入和输出缓冲区 以下几种情况会使缓冲区的内容被刷新 程序正常结束 缓冲区已满，再写入下一个值时会清空 用标准库的操作符，如endl 输入和输出流关联起来。在读入输出流时，会自动清空输入缓冲区。 缓冲对象主要分为三类： streambuf std::streambuf 是基类，定义了输入输出的基本接口。 std::stringbuf 和 std::filebuf 是 std::streambuf 的派生类，提供了具体的字符串和文件缓冲区的实现。 std::streambuf 本身不能直接使用，需要通过其派生类（如 std::stringbuf、std::filebuf）来进行实际的输入输出操作。 filebuf std::filebuf 是用于处理文件缓冲区的类，用于文件的读写操作。 可以将 std::filebuf 对象绑定到文件流上，与文件系统进行交互，实现文件数据的读写。 可以设置文件打开模式、操作文件指针等文件操作相关功能。 stringbuf std::stringbuf 是用于处理字符串缓冲区的类，可以在内存中动态创建和修改字符串数据。 是基于内存的字符串缓冲区，在内存中管理字符串数据。 主要用于处理字符串数据的输入输出操作，可以通过 std::stringstream 方便地对字符串数据进行读写。 各个流对象以及缓冲的关系 对于所有的流对象，不难看出都是基于虚基类ios_base派生而来，不同的流对象用于不同的输入和输出。 而每一个流对象都有个专门的类去管理缓冲区对象，完全可以通过流对象.rdbuf()观察其返回值。主要就是iostream和stringstream和fstream三个各自管理缓冲的类。 基于文件的输入和输出文件的概念文件是驻留在外存储器上，具有一个标识名和一组信息的集合，用于永久保存数据。 与文件相关的概念： 数据项：数据的基本单位，表示一个有意义的信息，如一个整型数，一个字符串。 记录：若干个相关的数据项组成一个记录，每个记录可以堪称一个对象 文件：记录的集合 数据库：一组相关的文件。 例如图书管理系统中，数据库包含书目文件，读者文件和其他辅助文件。书目文件中的每本书的信息构成一条记录。 每条记录中的书名，作者都是数据项。 文件和流 对于c++来说，文件就是一个个字节序列构成，每一个文件以文件结束符（End Of File ，EOF）结束，这种文件称为流式文件。 可以与字符串进行类比，只不过字符串结尾是’\\0’罢了 C++文件类型又分为二进制文件和ASCLL文件，对于ASCLL文件在读写时会在内存表示和文本之间进行转换。 二进制文件保存到则是数据在内存中的表示，直接交换数据，不执行任何转换。 访问文件主要有以下四个步骤 定义一个流文件对象 打开文件（将文件和流文件对象相关联） 操作文件的数据 关闭文件 1.定义文件流对象C++有三个流文件类型： ifstream:输入文件流，但程序从文件读入数据时，必须要定义一个ifstream类的对象与文件关联 0fstream:输出文件流，但程序输出数据到文件时，必须要定义一个ofstream类的对象与文件关联 fstream:输入输出文件流，fstream类的对象既可以读也可以写 1ifstream infile；//定义了一个输入文件流对象 2.打开和关闭文件文件流对象除了从istream和ostream继承下来的行为，还新增了俩个成员函数：open（打开文件），close（关闭文件），以及一个构造函数。 打开文件是将文件流对象与外存的某一文件关联起来，为文件的读写做好准备，例如：为文件流对象准备缓冲区，记录读写位置。 打开文件使用open函数（也可以定义流文件对象时通过构造函数） open函数有俩个参数： 文件名（c语言风格的字符串） 文件的打开模式 1inflie.open(&quot;文件名&quot;，文件打开模式)； 文件打开模式 含义 in 打开文件，做读操作（只适用于ifstream和fstream类） out 打开文件，做写操作（只适用于ofstream和fstream类） app 在文件尾后面添加（只适用于ofstream和fstream类） ate 打开文件后，立即将文件定位在文件尾i（所有类都有用） trunc 打开文件后，清空文件（只适用于ofstream和fstream类） binary 以二进制模式进行输入和输入，默认为ASCLL文件 每个文件流类都有默认的打开方式（就是自己不传入第二个参数时）: ifstream：以in模式默认打开 ofstream：以out模式打开 fstream：以in|out（既可读也可写）模式打开 12345678910111213141516171819#include &lt;fstream&gt;#include &lt;ifstream&gt;#include &lt;ofstream&gt;//打开一种是open函数，另一种就是申明的时候直接构造ifstream infile1;infile1.open(&quot;file1&quot;); //或者infile.open(&quot;file1&quot;,ifstream::in);ifstream infile2(&quot;file2&quot;); //或者infile2(&quot;file2&quot;,ifstream::in);ofstream outfile1;outfile1.open(&quot;file1&quot;); //或者outfile.open(&quot;file1&quot;,ifstream::out);ofstream outfile2(&quot;file2&quot;); //或者infile2(&quot;file2&quot;,ifstream::out);//注意当用out打开文件的时候，会自动清空文件（要写入文件时）outfile1.open(&quot;file1&quot;，ofstream::app);//如果要要向file2添加数据，则需要app打开方式//有时候既需要读也需要写，就选择fstreamfstream infile1(&quot;file1&quot;,fstream::in|fstream::out);//fstream默认以in和out的方式打开，且这种情况下不会清空文件。//如果只以out或者指定了truc模式，打开都会清空文件 TIPS：在打开文件后的操作，有一个良好的习惯就是检查文件是否打开成功。若打开成功，则流对象会是一个非零值，反之若未成功打开，则是一个零值。 12//在项目中我们使用的是,fstream的函数good检查文件是否打开成功file.good(); 在读写操作完时有比要显式的关闭文件。 1infile.close(); 表示流对象与文件断开关系，不在读写数据。 补充：其实流对象和文件的过程其实是缓冲对象与文件建立的过程，缓冲对象关联在流对象里(后面提到的打开模式in|out啥的，其实是针对filebuf) 所以下面的大体是可以看作一样的 12345678910111213141516#include &lt;iostream&gt;#include &lt;fstream&gt;int main() { // 创建一个 std::filebuf 对象并打开文件 std::filebuf filebuf; filebuf.open(&quot;example.txt&quot;, std::ios::out); // 创建一个 std::fstream 对象并关联到 filebuf std::fstream fstream; fstream.rdbuf(&amp;filebuf); // 使用 fstream 写入数据到 filebuf 关联的文件 fstream &lt;&lt; &quot;Hello, World!&quot;; // 关闭文件 filebuf.close(); return 0;} 123456789#include &lt;iostream&gt;#include &lt;fstream&gt;int main() { std::fstream fstream; fstream.open(&quot;example.txt&quot;); fstream &lt;&lt; &quot;Hello, World!&quot;; filebuf.close(); return 0;} 3.fstream的读取和写入对于文件的读取和写入应该是有很多方法的，不论是调用类内的函数，还是用外部getline（fstream，string）一行一行的读取或是其他，抑或是流操作符&gt;&gt;写入文件当前文件内指针指向的位置。日后有时间慢慢补，这里就只展示一段项目使用到的读取fstream吧 123456std::fstream file(path); //打开地图的csv文件std::string str_line; //csv文件的getline都是按行读的while (std::getline(file, str_line))//每次读取file的一行，写入string对象{ ......//一行一行读取csv文件，并且写入瓦片数据} 基于字符串的输入输出这里就只简单介绍stringstream类 std::stringstream 是 C++ 标准库中的一个类，它提供了一个方便的方式来处理字符串和流。主要用途包括以下几个方面： 将其他类型转换为字符串：std::stringstream 可以将基本数据类型（如 int、double 等）或自定义类型转换为字符串形式。通过输入流操作符 &lt;&lt; 将数据插入到 std::stringstream 中，当然也可以将可以从一个字符串中提取数据，并将其转换为其他类型。然后可以通过 str() 函数获取到整个字符串。这种功能对于将其他类型转换为字符串输出或者进行字符串拼接非常有用。 1234567891011121314151617181920#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;string&gt; int main() { int num = 123; std::stringstream ss; ss &lt;&lt; num; // 将整数放入流中（转化为字符串存入） std::string str = ss.str(); // 使用str()函数 从流中提取字符串 std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出：123 //拼接 ss&lt;&lt;num; std::cout &lt;&lt; ss.str() &lt;&lt; std::endl; // 输出：123123 ss.str(&quot;&quot;);//清空 ss&lt;&lt;&quot;246&quot;; ss&gt;&gt;num; //自动将字符串转化为变量对应的类型写入变量 std::cout&lt;&lt;num;//输出123} 中间缓冲：std::stringstream 可以作为中间缓冲区来处理字符串数据。可以将不同的数据类型、格式化文本等按顺序插入到 std::stringstream 中，在最后一次性输出或处理整个字符串数据。这样可以更加灵活和高效地操作字符串内容。 字符串处理：通过 std::stringstream 的接口函数，可以对字符串进行各种操作，如插入、删除、替换等。这使得对字符串的处理更加方便和高效。 常用的读取方式1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std; int main(){ stringstream ss(&quot;hello world&quot;); string str; // 注意： stringstream 是一个单词一个单词 ”流入“ string 的，就是以空格为停止 while (ss &gt;&gt; str) { cout &lt;&lt; str &lt;&lt; endl; } //这个和上面一样，以空格为分割字符不断读入（get和getline的读取之后也可以整理一下） //注意分隔符是字符，不是字符串 while(getline(ss,str,' ')) { cout&lt;&lt;str&lt;&lt;endl; } return 0;} /*hello world*/ 最后就分析一下项目代码 12345678std::fstream file(path); //其实文件打开就是加载到缓存（内存中的一块地方）if (!file.good())return false;std::stringstream str_stream; //创建对应的流字符串来对文件的缓存的内容读入读出，string是不可以进行流操作的 str_stream &lt;&lt; file.rdbuf(); //让对应的流字符串对象读取文件所有内容（rdbuf，其实就是readbuffer，读取缓存）file.close(); //读取后文件关闭cJSON* json_root = cJSON_Parse(str_stream.str().c_str()); //paese（解析），以cJSON去解析这些数据，参数是C语言风格的字符串。 以fstream对象打开文件 将file文件的内容写入stringstream对象 file.rdbuf();返回的是与文件关联的缓冲对象filebuf*(指针). 应该是stringstream有重载&lt;&lt;运算符(关于filebuf*),可以从filebuf关联的文件中读取所有内容进入stringstream对象 读取后关闭文件 将stringstream对象转换为string,再进一步转化为char* (c语言风格字符串),最后利用cJSON库将其转化为cJSON对象,之后就可以利用其指针json_root读取json文件格式了 总结:在我看来,在文件的格式的转化中,stringstream就相当于在转换中建立了桥梁,fstream帮忙打开文件,stringstream负责读取流文件的内容,最后再根据stringstream对象转换为string进一步char*,供cjson读取,成功获取了我们需要的json格式的内容.","link":"/articles/c++%E8%AF%AD%E6%B3%95/c++%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"title":"","text":"AVL树解析（基于查找二叉树（dynamicSearchTree））平衡二叉树：在查找二叉树的基础上要求每个节点左右字节点的高度差不能超过一。 于是对于节点多了一个数据成员高度来实现这一功能。 先附上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;dynamicSearchTable.h&quot;template &lt;class KEY, class OTHER&gt;struct SET{ KEY key; //关键字信息 OTHER other; //和其他信息};template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x);private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); bool remove(const KEY&amp; x, AvlNode*&amp; t); void makeEmpty(AvlNode* t); int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} void LL(AvlNode*&amp; t); void LR(AvlNode*&amp; t); void RL(AvlNode*&amp; t); void RR(AvlNode*&amp; t); int max(int a, int b) { return (a &gt; b) ? a : b;} bool adjust(AvlNode*&amp; t, int subTree);};template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) { if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; else return (SET&lt;KEY, OTHER&gt;*)t; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;left; t-&gt;left = t1-&gt;right; t1-&gt;right = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); LL(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) { insert(x, t-&gt;left); if (height(t-&gt;left) - height(t-&gt;right) == 2) if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); else LR(t); } else if (t-&gt;data.key &lt; x.key) { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;}template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; if (x == t-&gt;data.key) { if (t-&gt;left == NULL || t-&gt;right == NULL) { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; return false; } else { AvlNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; if (remove(tmp-&gt;data.key, t-&gt;right))return true; return adjust(t, 1); } } if (x &lt; t-&gt;data.key) { if (remove(x, x-&gt;left))return true; return adjust(t, 0); } else { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } RR(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; }}template&lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::makeEmpty(AvlNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;} 基本组成成员 AvlNode（AVL的树节点） 12345678910struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; //节点的高度 AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h=1):data(element),left(lt),right(rt),height(h){} }; 多了一个高度，构造函数默认为1（指只有自己） 根节点 1AvNodee* root; AVL类的基本数据成员和函数12345678910111213141516171819202122232425262728293031template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数 void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有） void remove(const KEY&amp; x); //删除函数（公有）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); //插入函数（私有） bool remove(const KEY&amp; x, AvlNode*&amp; t); //删除函数（私有） void makeEmpty(AvlNode* t); //清空 int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} //计算当前节点的高度 void LL(AvlNode*&amp; t); //单旋转LL void LR(AvlNode*&amp; t); //双旋转LR void RL(AvlNode*&amp; t); //双旋转RL void RR(AvlNode*&amp; t); //单旋转RR int max(int a, int b) { return (a &gt; b) ? a : b;} //比较函数 bool adjust(AvlNode*&amp; t, int subTree); //调整节点的结构使其平衡的函数}; 其实private类的函数都是公有类函数的工具函数 函数的实现分析 查找函数（find） 123456789101112template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) //循环停止的条件，就是当前节点为空或者就是要找的 { //小于就换成左节点，反之换成右节点， if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; //空就返回 else return (SET&lt;KEY, OTHER&gt;*)t; //这里还是强制转换} 还是基于二叉查找树的特性，只是没有使用递归函数，这种方式被称为迭代实现 插入函数（insert） 在介绍函数之前理解一些东西，关于插入的一些特性： 1. 首先插入还是和二叉查找树一样插入在叶子节点上 2. 一次插入后，只有在插入点到根的路径上的节点才有可能发生平衡度的变化 3. AVL的平衡策略最多只要调整一个节点就可以了 主要分析LL和LR俩种情况注意： 对于旋转策略的核心是保证节点的高度不发生变化，就是通过旋转变为原来的高度，从而保证对上面节点安全的保证。 一旦改变了数的高度，那需要不断往上检索，直到那个节点的高度没有发生变化 LL：原来A的左子树比右子树高，插入发生在A的左儿子的左子树中，使A的左子树增高 (注意（仅仅对于插入而言，对于删除这个结论反而相反）：平衡度只是一种高度是否平衡的表现形式，真正影响的是节点的高度，主要体现在平衡度向零趋近高度不变，而向俩边增长表明节点高度发生改变) 此图有图 节点平衡度从-1到0但是并不影响上面的节点，因为这个节点的高度并未发生改变，反而0到1表明当前节点的高度发生改变 现在来分析LL的情况此处有图 首先分析一下一些情况： 1. **首先B的平衡度一定原来是0，然后变为1， 因为我们上面解释过如果是-1到0表明是向零趋近，B的高度不会发生变化，进而不会影响A 若是原来是1，变成2，显然B才是危机节点，处理就不是A了 对于LL解决办法就是向右旋转 此处有图 显然我们发现在旋转后我们发现我们处理的这个树的高度与插入前的高度完全一样，于是不用担心上面节点的平衡度了 思考： 对于这种旋转必然是左右子树未实现满二叉树或者完全二叉树导致，就是有空缺的位置来保证旋转后高度不发生变化 那么假设是满二叉树插入，我们会发现并不影响平衡度都从（0到1或者0到-1） （其实这就是插入点后的检索过程，虽然高度发生了变化，但是一直向上检索发现平衡度没有打破规则，那么就会检索到根节点结束） 现在附上LL代码图 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) //注意这里传的是原来的指针，估计是父节点的指针，不然改了没意义 A{ AvlNode* t1 = t-&gt;left; //失衡的A，先标记B点为t1（A的左子节点） t-&gt;left = t1-&gt;right; //B的右子树，变成A的左子树 t1-&gt;right = t; //B的右子节点变成A t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //此时更新各自的高度（+1是为了包括本身） t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; //将t彻底变为B点（B成为t的指向点）} 有心情的话 可以在这个补一个过程图，看我以后记不记的住吧 *1.*我们发现指针还是引用传递，主要是我要旋转A点，那么就需要修改A的父节点对应的指针从。原理和二叉查找树的原理相同 RR也是同理只是向左旋转附上RR的代码 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) //这个和上面是一个道理，就是向左转，就像镜像一样{ AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;} 现在来分析LR的情况为什么要单独讨论这种情况？因为我们发现仅仅如果使用LL右旋发现只是不过对这个树镜像对称过去了而已，A点仍然是失衡点，只不过是现在是右子树高了 此处有图 我们相对于之前多了一个参考C节点，对于CL和CR谁的高度为h-1并不重要 为了保证根节点的高度不发生变化，我们选择LR的双旋转的方法，对B点进行左旋转（RR），再对A点进行右旋转（LL） 不难发现，C点占据了原来的根节点，且平衡度恢复了0，因为是1到0我们便可认定节点的高度没有发生变化，从而无需再向上检索 过程如下图显示 其实逻辑也很好理解就是让根节点的右边多一个高度来平衡多的那个节点 代码如下 123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); //先对B进行左旋 LL(t); //再对A点进行右旋} RL也完全是同理，就是对称了一下123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);} 以上我们分析了四种旋转情况接下来就来分析插入函数前面我们提到了一个关键词回溯 对于代码里面的回溯就是在修改后往回检查，最好想的就是树了，我修改了叶节点，我需要对查找路径上的每一个点进行检查，那么我们在代码中如何往回实现这个功能呢？ 答案就是利用 递归 假如我们要进行修改，并检查，可以用如下伪代码实现 12345678910插入函数{检查当前节点是不是插入点，是就插入不是就根据于当前节点的大小调用“函数（左节点）/函数（右节点）”//因为是递归调用，执行到这一样表示递归所有的修改已完成开始回溯了检查当前节点的平衡度来看是否需要调整，若失衡分类讨论重新计算高度} 附上代码 其实我们发现这个回溯必须全部走完，因为要更改高度（尤其是满二叉树那种虽然不影响平衡度，但是路径上所有节点高度都需要+1） 1234567891011121314151617181920212223242526272829303132template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) //情况1：如果根节点为空就直接放置 t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) //情况2：如果比当前节点小，往左子树插入 { insert(x, t-&gt;left); //向下递归 if (height(t-&gt;left) - height(t-&gt;right) == 2) //执行到这一步表示左子树全部节点都平衡了，检查自己了 if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); //当前节点失衡了，只要判断插入节点是在左子节点的左右 //就可以判断是哪种情况 else LR(t); } else if (t-&gt;data.key &lt; x.key) //这里的逻辑是一样的，参照上面就行了 { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //在最后插入好，会从底往上重新计算树的高度} 删除函数（remove） 删除节点很有可能导致树变矮，导致二叉树失衡，所以必须要在删除后不断回溯调整平衡 首先这是一个回溯的过程，还有一个关键点就是是否需要再网上回溯的关键是: 的当前节点的高度在调整后或者未调整高度是否发生变换，注意我说的是高度不是平衡度，若往回检索发现有节点高度未发生变化就可以停止检查调整步骤直接return。 这也表明了虽然删除是递归，但是返回值是一个bool表示当前节点高度是否发生变化从而决定上面的节点是否需要检查 删除过程这一个和二叉查找树没什么区别其实，依旧是分为三种情况（无儿子，一个儿子，俩个儿子） 前俩个可以用一个表达式来代替 1t=（t-&gt;left!=NULL）:t-&gt;left?t-right; 相对后面的情况显示是迭代找到可替换的叶子节点，然后删除叶子节点啦。 检查过程删除的时候没有插入那么幸运，删除时的调整很有可能导致整棵树高度下降，从而影响路上的所有父节点。 停止条件：只有当某个节点读的高度在删除后不变才无需向上检查调整了 导致树的高度发生变化有以下几种情况 （注意：这里平衡度是在向两边增长节点高度不变，向零靠近节点高度发生变化，因为是删除 （与插入的结论恰恰相反，插入是有可能增高，而删除是有可能降低高度）） 此处有五种情况（假设都是在左子树上删除的节点） 此处有图 对于（a）的平衡度既没有失衡，高度也没有发生变化 对于（b）平衡度没有失衡，但是根据平衡度的变化可以发现节点的高度发生变换，需要检查父节点 对于（c）只需要节点P使用左旋（RR）即可，这样根节点的高度就变成了0，虽然平衡了但是平衡度从-1变为0，节点高度发生变化，需要检查父节点 对于（d）显然左旋仍然导致失衡，就像前面的RL的情况一样发生在内侧，这个时候就需要先对P的右子节点先右旋（LL）再对P进行左旋（RR），就会使根节点平衡度变为0.不需要对父节点进行检查 对于（e）对P使用简单的左旋（RR）根节点（原来P的位置）的平衡度变为1（注意平衡度从-1到1，节点的高度并未发生变化，可以认为就像交换了一样）；当然可以使用RL，这样的话根节点的平衡度仍为-1，高度未发生变化。所以俩种方法都不需要检查父节点 对于添加在右子节点的方法对称就好了 附上代码 （指针参数还是引用，原因上面解释过了） （true表示不用检查，false表示节点的高度发生变化，需要检查节点的高度） 删除函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; //空树不存在，不用检查父节点 if (x == t-&gt;data.key) //情况1：如果是当前节点 { if (t-&gt;left == NULL || t-&gt;right == NULL) //删除情况1，2：如果只是有一个子节点或者没有节点 { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; //因为对只有一个节点或者无叶节点的删除必然导致高度变换，肯定是 return false; //要检查的 } else { AvlNode* tmp = t-&gt;right; //删除情况三：有俩个子节点 while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //迭代找到右子树的最左子节点 t-&gt;data = tmp-&gt;data; //数据替换 if (remove(tmp-&gt;data.key, t-&gt;right)) //然后就是删除的目标换成最新的叶节点，从当前的节点右节点开始 return true; //如果这个删除最后返回的是true，表明右子节点的高度未变化 return adjust(t, 1); //1表示删除在右子树上，t表示当前节点失衡，需要调整 } } if (x &lt; t-&gt;data.key) //情况2：小于则是向左找 { if (remove(x, x-&gt;left))return true; //向左递归 return adjust(t, 0); //如果需要检查，则调用adjust，0表示删除的是左子树 } else //情况三：大于则是向右找 { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }} 这段逻辑其实挺绕人的，remove函数的返回值主要三种： 1：删除的是只有一个字节点或者无子节点（直接返回true，必然改变高度） 2：向下递归调用remove，如果调用返回的是true，则自己不用调整，也返回true 3：如果调用的remove返回false，则需要返回adjust，一边检查高度是否发生变换+调整，调整后如果高度变化返回false，反之true（具体就是我们讨论的几个调整情况） 调整函数（adjust） 参数subTree（subtract Tree）1表示删除的右子树，0表示删除的左子树 0则是我们讨论的那五种情况 1则是完全对称的五种情况 调用adjust不一定高度有变化，但是平衡度一点是发生变化了 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) //如果删除的是右子树，逻辑和下面的只是镜面对称 { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else //如果删除的是左子树 { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; //对应（a）删除的左子树，如果是当前平衡度为-1，表示之前的平衡度就是0（如果是-1的话根本不会调用adjust好吧），因为删除是左子树，只有左子树降低高度的可能，（表示根据前面由平衡度判断高度结论判定）当前节点不需要调整+高度也没有发生变化 if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } //对应情况（b），根据结论一定是从1到0，高度一定发生变化了，但是平衡度依旧正常，返回false if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } //对应情况（d），右子节点的左子树的节点的高度大于右子树进行RL RR(t) if (height(t-&gt;right) == height(t-&gt;left)) return false; else return true; //对于（c）和（e）只需要RR（左旋即可），对于这两种情况使用RR后的区别就是（c）调整后平衡度为0，节点高度发生变化return false，对于（e）使用RR，节点应该变为1，但是高度没有发生变化，return true }} 到此难的地方已经处理好了其他的构造析构都是完全继承完全二叉树，所以不再赘述了 有时间再补补性能分析吧","link":"/2024/06/09/AVL/"},{"title":"cjson库解析json文件","text":"利用cJSON库来解析json文件 cJSON是一个使用C语言编写的JSON数据解析器，具有超轻便，可移植，单文件的特点，使用MIT开源协议。 #include &lt;cJSON.h&gt;使用前需要引用这个库 同时将csjon.c放到工程目录 JSON语法规则JSON对象是一个无序的”名称/值”键值对的集合： 以”{“开始，以”}“结束，允许嵌套使用； 每个名称和值成对出现，名称和值之间使用”:“分隔； 键值对之间用”,“分隔 在这些字符前后允许存在无意义的空白符； json常见对象类型1234567891011cjson对应json对象给出的类型宏 #define cJSON_Invalid (0)#define cJSON_False (1 &lt;&lt; 0)#define cJSON_True (1 &lt;&lt; 1)#define cJSON_NULL (1 &lt;&lt; 2)#define cJSON_Number (1 &lt;&lt; 3)#define cJSON_String (1 &lt;&lt; 4)#define cJSON_Array (1 &lt;&lt; 5)#define cJSON_Object (1 &lt;&lt; 6)#define cJSON_Raw (1 &lt;&lt; 7) /* raw json */ 对于键值，可以有如下值：） 一个新的json对象（cJSON_Object） 数组：使用”[“和”]“表示（cJSON_Array ） 数字：直接表示，可以是整数，也可以是浮点数（cJSON_Number） 字符串：使用引号&quot;表示（cJSON_String） 字面值：false、null、true中的一个(必须是小写)（ cJSON_Invalid,cJSON_False,cJSON_True,cJSON_NULL) 示例： 1234567891011121314{ &quot;name&quot;: &quot;mculover666&quot;, //键为name，值为string &quot;age&quot;: 22, //值为number &quot;weight&quot;: 55.5, &quot;address&quot;: //address是一个对象object，里面有俩个属性 { &quot;country&quot;: &quot;China&quot;, &quot;zip-code&quot;: 111111 }, &quot;skill&quot;: [&quot;c&quot;, &quot;Java&quot;, &quot;Python&quot;], //skill是一个数组对象，里面是string &quot;student&quot;: false //这就是一个字面值false} cJson结构体12345678910111213typedef struct cJSON{ struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; int valueint; double valuedouble; char *string;} cJSON; 首先，它不是将一整段JSON数据抽象出来，而是将其中的一条JSON数据抽象出来，也就是一个键值对，用上面的结构体 strcut cJSON 来表示，其中用来存放值的成员列表如下： String：用于表示该键值对的名称；就是对象的名称 type：用于表示该键值对中值的类型； valuestring：如果键值类型(type)是字符串，则将该指针指向键值； valueint：如果键值类型(type)是整数，则将该指针指向键值； valuedouble：如果键值类型(type)是浮点数，则将该指针指向键值； 其次，一段完整的JSON数据中由很多键值对组成，并且涉及到键值对的查找、删除、添加，所以使用链表来存储整段JSON数据，如上面的代码所示： next指针：指向下一个键值对 prev指针指向上一个键值对 最后，因为JSON数据支持嵌套，所以一个键值对的值会是一个新的JSON数据对象（一条新的链表），也有可能是一个数组，方便起见，在cJSON中，数组也表示为一个数组对象，用链表存储，所以： 在键值对结构体中，当该键值对的值是一个嵌套的JSON数据或者一个数组时，由child指针指向该条新链表。 12345678910111213141516171819202122232425262728293031323334[{ &quot;interval&quot;: 1, &quot;rewards&quot;: 100, &quot;spawn_list&quot;: [{ &quot;interval&quot;: 1, &quot;point&quot;: 1, &quot;enemy&quot;: &quot;Slim&quot; }, { &quot;interval&quot;: 1, &quot;point&quot;: 2, &quot;enemy&quot;: &quot;KingSlim&quot; }, { &quot;interval&quot;: 1, &quot;point&quot;: 1, &quot;enemy&quot;: &quot;Goblin&quot; }, { &quot;interval&quot;: 1, &quot;point&quot;: 2, &quot;enemy&quot;: &quot;GoblinPriest&quot; }, { &quot;interval&quot;: 1, &quot;point&quot;: 1, &quot;enemy&quot;: &quot;Skeleton&quot; }] }, { &quot;interval&quot;: 3, &quot;rewards&quot;: 100, &quot;spawn_list&quot;: [{ &quot;interval&quot;: 3, &quot;point&quot;: 2, &quot;enemy&quot;: &quot;KingSlim&quot; }] }]//本身整体就是一个大数组，大数组里面有俩个{}{}对象其实是波次，波次里面还有三个对象，间隔，奖励，敌人列表（又是数组） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192bool load_level_config(const std::string&amp; path){ std::fstream file(path); if (!file.good())return false; std::stringstream str_stream; str_stream &lt;&lt; file.rdbuf(); file.close(); cJSON* json_root = cJSON_Parse(str_stream.str().c_str()); if (!json_root) return false; if (json_root-&gt;type != cJSON_Array) { cJSON_Delete(json_root); return false; } cJSON* json_wave = nullptr; cJSON_ArrayForEach(json_wave, json_root) { if (json_wave-&gt;type != cJSON_Object) continue; wave_list.emplace_back(); Wave&amp; wave = wave_list.back(); cJSON* json_wave_rewards = cJSON_GetObjectItem(json_wave, &quot;rewards&quot;); if (json_wave_rewards &amp;&amp; json_wave_rewards-&gt;type == cJSON_Number) wave.rewards = json_wave_rewards-&gt;valuedouble; cJSON* json_wave_interval = cJSON_GetObjectItem(json_wave, &quot;interval&quot;); if (json_wave_interval &amp;&amp; json_wave_interval-&gt;type == cJSON_Number) wave.interval = json_wave_interval-&gt;valuedouble; cJSON* json_wave_spawn_list = cJSON_GetObjectItem(json_wave, &quot;spawn_list&quot;); if (json_wave_spawn_list &amp;&amp; json_wave_spawn_list-&gt;type == cJSON_Array) { cJSON* json_spawn_event = nullptr; cJSON_ArrayForEach(json_spawn_event, json_wave_spawn_list) { if (json_spawn_event-&gt;type != cJSON_Object) continue; wave.spawn_event_list.emplace_back(); Wave::SpawnEvent&amp; spawn_event = wave.spawn_event_list.back(); cJSON* json_spawn_event_interval = cJSON_GetObjectItem(json_spawn_event, &quot;interval&quot;); if (json_spawn_event_interval &amp;&amp; json_spawn_event_interval-&gt;type == cJSON_Number) spawn_event.interval = json_spawn_event_interval-&gt;valuedouble; cJSON* json_spawn_event_spawn_point = cJSON_GetObjectItem(json_spawn_event, &quot;point&quot;); if (json_spawn_event_spawn_point &amp;&amp; json_spawn_event_spawn_point-&gt;type == cJSON_Number) spawn_event.spawn_point = json_spawn_event_spawn_point-&gt;valueint; cJSON* json_spawn_event_enemy_type = cJSON_GetObjectItem(json_spawn_event, &quot;enemy&quot;); if (json_spawn_event_enemy_type &amp;&amp; json_spawn_event_enemy_type-&gt;type == cJSON_String) { const std::string str_enemy_type = json_spawn_event_enemy_type-&gt;valuestring; if (str_enemy_type == &quot;Slim&quot;) spawn_event.enemy_type = EnemyType::Slim; else if (str_enemy_type == &quot;KingSlim&quot;) spawn_event.enemy_type = EnemyType::KingSlim; else if (str_enemy_type == &quot;Skeleton&quot;) spawn_event.enemy_type = EnemyType::Skeleton; else if (str_enemy_type == &quot;Goblin&quot;) spawn_event.enemy_type = EnemyType::Goblin; else if (str_enemy_type == &quot;GoblinPriest&quot;) spawn_event.enemy_type = EnemyType::GoblinPriest; } } if (wave.spawn_event_list.empty()) wave_list.pop_back(); } } cJSON_Delete(json_root); if (wave_list.empty()) { return false; } return true;} 首先利用fstream打开文件，利用stringstream读取文件的内容，然后转换为c语言风格的字符串格式，利用其转化为cjson形式的对象，并返回指针。首先获取的就是数组对象，波次数组 1. cJSON json_root = cJSON_Parse(str_stream.str().c_str());（将c风格char的字符串转换为cjon格式并返回指针） 然后再创建一个cjosn指针遍历这个数组，有专门的遍历函数 2.cJSON_ArrayForEach(json_wave, json_root)（类似for(int &amp;tmp:(vector object)） 然后在读取的又是一个对象{} 1if (json_wave-&gt;type != cJSON_Object)//检查读取的是否正确 进一步读取对应的键值 3.cJSON json_wave_rewards = cJSON_GetObjectItem(json_wave, “rewards”);* 123456cJSON* json_wave_rewards = cJSON_GetObjectItem(json_wave, &quot;rewards&quot;);if (json_wave_rewards &amp;&amp; json_wave_rewards-&gt;type == cJSON_Number) wave.rewards = json_wave_rewards-&gt;valuedouble;//显示第一个波次对象{}，获取键为“rewards”的对象指针，然后检查其是否存在值的类型是否为数值//然后数值存在valuedouble变量里面 后面读取敌人生成序列的逻辑也是一样的 cJSON使用过程中的内存问题内存及时释放cJSON的所有操作都是基于链表的，所以cJSON在使用过程中大量的使用malloc从堆中分配动态内存的，所以在使用完之后，应当及时调用下面的函数，清空cJSON指针所指向的内存，该函数也可用于删除某一条数据： 123cJSON_Delete(cJSON *item);//本段删除最初的节点cJSON_Delete(json_root); 注意：该函数删除一条JSON数据时，如果有嵌套，会连带删除。","link":"/articles/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/cjson/"},{"title":"csv文件解析","text":"CSV简单的读取CSV代表Comma Separated Values。CSV文件是一种纯文本文件，用于存储表格和电子表格信息。内容通常是由文本、数字或日期组成的表格。使用将数据存储在表中的程序可以轻松导入和导出CSV文件。 CSV文件格式通常CSV文件的第一行包含表格列标签。后面的每一行表示表中的一行。逗号分隔行中的每个单元格，这就是名称的来源。 下面是一个CSV文件的示例。 正常txt文本打开（程序读取的形式） 电子表格形式 其实读取csv文件就是读取正常的字符串文件，就是记住csv格式 每一行的每个对象之间用逗号分割，行与行之间就是换行符，不用逗号，塔防游戏就用来存放地图瓦片数据 直接根据实例解释 123456789101112131415161718192021222324252627282930313233343536373839bool load(const std::string&amp; path){ std::fstream file(path); if (!file.good())return false; TileMap tile_map_temp; int idx_x = -1, idx_y = -1; std::string str_line; while (std::getline(file, str_line)) { str_line = trim_str(str_line); if (str_line.empty()) continue; idx_x = -1, idx_y++; tile_map_temp.emplace_back(); std::string str_tile; std::stringstream str_stream(str_line); while (std::getline(str_stream,str_tile,',')) { idx_x++; tile_map_temp[idx_y].emplace_back(); Tile&amp; tile = tile_map_temp[idx_y].back(); load_tile_from_string(tile, str_tile); } } file.close(); if (tile_map_temp.empty() || tile_map_temp[0].empty()) return false; tile_map = tile_map_temp; generate_map_cache(); return true;} getline(file, str_line) 一行一行读取csv文件，读入string类，一行的内容指导换行符，为了保证读取争取必须删除最后的的可能存在的空格 1234567891011121314std::string trim_str(const std::string&amp; str){ size_t begin_idx = str.find_first_not_of(&quot; \\t&quot;); //该函数时返回第一个不在提供字符串的字符索引 if (begin_idx == std::string::npos) //npos表示查询越界全空，返回空字符串 return &quot;&quot;; size_t end_idx = str.find_last_not_of(&quot; \\t&quot;); //找到最后的一个不是换行或者空格 size_t idx_range = end_idx - begin_idx + 1; //计算有效字符串的范围 return str.substr(begin_idx, idx_range); //截取需要的字符串 //“2/2,3/2,3/2 ”-&gt;处理后“2/2,3/2,3/2”(空格没了)} 然后依次以逗号为分割符依次读取每一个瓦片数据 1while (std::getline(str_stream,str_tile,',')) 然后瓦片又以“/”为分隔符读取 1while (std::getline(str_stream, str_value, '\\\\')) //从str_stream中逐个读取到str_value,，然后去转换","link":"/articles/%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/csv/"},{"title":"","text":"二叉查找树 先附上完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133template &lt;class KEY,class OTHER&gt;struct SET{ KEY key; OTHER other; };template&lt;class KEY,class OTHER&gt;class dynamicSearchTable{public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; virtual void remove(const KEY&amp; x) = 0; virtual ~dynamicSearchTable() {};};template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; public: BinarySearchTree(); ~BinarySearchTree(); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x); private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); void remove(const KEY&amp; x, BinaryNode*&amp; t); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; void makeEmpty(BinaryNode* t);};template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) return (SET&lt;KEY,OTHER&gt;*)t; if (x &lt; t-&gt;data.key) return find(x.t-&gt;left); else return find(x, right); }template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) insert(x, t-&gt;right);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ if (t == NULL)return; if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; remove(t-&gt;data.key, t-&gt;right); } else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; }}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL;}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root);}int main(){ return 0;} 前提组成 template &lt;class KEY,class OTHER&gt; struct SET { KEY key; //关键字信息 OTHER other; //和其他信息 }; 123456789101112131415 这是基本的数据元素 分别包括**键值**key和**其他值**value（就像字典里面对应的查找关键和词语解释）- ~~~c++ template&lt;class KEY,class OTHER&gt; class dynamicSearchTable { public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; //查找目标元素，返回值为指针 virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; //插入功能 virtual void remove(const KEY&amp; x) = 0; //显然是删除功能 virtual ~dynamicSearchTable() {}; //析构函数 }; 这就是二叉查找树的父类**动态查找表**，也可以看作一个模板而已，提供了基础的一个动态查找的基本功能模板 动态二叉树 动态二叉树的主体类函数 1234567891011121314151617181920212223242526template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root;public: BinarySearchTree(); //构造函数 ~BinarySearchTree(); //析构函数 SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数（公有，面向使用者） void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有，面向使用者） void remove(const KEY&amp; x); //删除函数（公有，面向使用者）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); //查找函数（私有，面向公有调用函数） void remove(const KEY&amp; x, BinaryNode*&amp; t); //插入函数（公有，面向公有调用函数） SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; //删除函数（公有，面向公有调用函数） void makeEmpty(BinaryNode* t); //清空函数}; 树的节点分析： 123456789struct BinaryNode { SET&lt;KEY, OTHER&gt;data; //本体的数据 BinaryNode* left; //左子节点的指针 BinaryNode* right; //右子节点的指针 BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, //节点的构造函数，可以直接设定三个成员 BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 注意：后面经常会用到公有函数调用私有函数，虽然名称一样，但一个面向使用者，私有的面向共有的函数调用内部 12345void remove(const KEY&amp; x) //删除函数（公有，面向使用者）{ remove(x,root); //这里调用的就是私有函数}void remove(const KEY&amp; x, BinaryNode*&amp; t); //这就是私有函数的接口和实现 接下来分析函数的实现 构造函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL; //简单初始化了一下根节点} makempty 主要还是递归循环删除，采用了前序遍历的思想 12345678template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; //递归终止的条件（删到了空节点） makeEmpty(t-&gt;left); //正常步骤先删左节点，往下递归 makeEmpty(t-&gt;right); //再删右节点，往下递归 delete t; //删除自己 }//最后就删除了所给节点和节点的所有子节点 拓展：其实最近刷题还看到了一种实现方法就是入队和出队在这里 优点：就是摆脱了递归的对于空间的大量调用，利用循环和队列实现（更多是在链表使用的方法） 其实这是层序遍历的使用方法，只是用这个实现了层序遍历的删除方式 123456789101112131415&gt;**自己拓展的，不是范例的**&gt;Queue&lt;BinaryNode*&gt; queue; //存放节点指针的队列&gt;template&lt;class KEY, class OTHER&gt;&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)&gt;{queue.enqueue(t); //先把根节点放入队列 while(t.isempty()) //终止条件：检查队列是否为空，不空则继续进行 { BinaryNode* t=queue.dequeue(); //出队队列的第一个节点 if(t-&gt;left!=nullptr)queue.enqueue(t-&gt;left); //左子节点有就放进队列，没则不处理 if(t-&gt;right!=nullptr)queue.enqueue(t-&gt;right); //同理 delete t; //然后删除自己 }&gt;} 析构函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root); //就从root开始删除，很简单，不解释了} 插入函数（insert） 从这插入函数观察二叉树的构成特点：左子节点小于父节点，右子节点大于父节点（节点不会重复） 这个特点就导致插入的时候有一个特性：以这个特点往下寻找插入点必然是叶节点，从而使插入特别方便。 函数还是递归实现的函数，逐次往下寻找（二叉树的结构导致如果树高了必然会导致搜索耗费大量的时间，之后会有扁平的处理方法） 1234567891011121314151617template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root); //表示从根节点往下寻找插入点}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); //若根节点不存在，则直接存进去 else if (x.key &lt; t-&gt;data.key) //若小于当前节点则向左递归 insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) //大于则向右递归 insert(x, t-&gt;right); //等于的情况直接退出不干，二叉树的插入必须是不同} 查找函数（find） 查找函数就是基于二叉树的结构特点建立的，左小右大 123456789101112131415template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) //如果是不存在或者就是当前的节点 return (SET&lt;KEY,OTHER&gt;*)t; //找到就返回这个指针,没有的话就是返回空指针 if (x &lt; t-&gt;data.key) //如果小于则向左找 return find(x.t-&gt;left); else return find(x, right); //大于则向右找} 注意：有人可能会注意到，t不是BinarNode吗，怎么能强制转换为SET类的指针啊 1return (SET&lt;KEY,OTHER&gt;*)t; 这里需要解释一下结构体和类的一个特点： 对于类和结构的存贮使从第一个数据成员开始的。 举个例子：对于BinarNode的存储空间第一个就是存放的SET，因为在定义里面是写在第一个的。 从而对于指向BinaryNode存储空间的指针某种意义上也是指向了SET的开头，进而可以进行强制转换 12345678910//树节点的结构体struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 删除函数（remove） 主体思路： 删除大体是这个思路为了保证树的结构不变，主要分三种情况 1.如果这个删除节点没有度数为0，很简单删除就好了 2.只有一个子节点，把字节点复制上去，把字节点删除 3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数 其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点） 对于这题我们假设向右子节点寻求最接近的值 最关键的是： 首先，替代问题，为了保证稳定性必须要替换一个最接近的节点互换位置，顶替 其次由于结构最接近无非 最近但小于（左节点的最右节点）和最近但大于 （右节点的最左字节点） 这个寻找方法便捷的地方在于必然是叶子节点替换，也易于删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445//这里的实现主要是最右子节点最左节点（大于且最靠近的树）template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ //先找到要删除的节点 if (t == NULL)return; //第一种情况空节点返回 if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); //第二种情况，要删除小于当前节点，往左递归 else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); //第三种情况要找的大于当前节点，往右边递归 else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //循环找到右子节点的最左节点 t-&gt;data = tmp-&gt;data; //替换俩个节点顺序 remove(t-&gt;data.key, t-&gt;right); //删除替换后的叶子节点，结束 } //第四种，找到了当前节点就是要删除的节点，但是左右都有子节点 else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; //如果有一个子节点，t就是直接替换为子节点，然后删除原来的节点，即使没有子节点，t变为空间点也合乎逻辑 delete oldNode; } //第五种，找到了要么一个子节点，要么没有 //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理} 有一点需要注意： 1&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t) 我们发现节点的参数传递都是引用传递，那是为了方便节点直接替换 例如remove，正是因为引用传递，在层层递归中确保每次传下来的t都是确确实实来自于父节点里面直接的左右节点的指针 这样就维持了上下关系，确保修改是有效的 ##总结：至此就分析结束了 （有时间在这里补一个二叉树查找性能的分析）","link":"/2024/06/08/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8dynamicSearchTree%EF%BC%89/"},{"title":"map&amp;&amp;unordered_map","text":"map&amp;&amp;unordered_mSTLap 恰巧看到大V老师使用unordered_map来实现了资源池，那么便想在分析池的概念前，先弄清这个STL的提供的结构 将分析pair，map，unordered_map 我们将解决课程的以下疑问 unordered_map的实现方法和map的区别（主要是解释map）？ 为什么大v老师的使用下标【】的方法就可以构建新的对象？ 大v老师的键值使用了枚举，那么对于unordered_map键值类型限制和map的键值类型限制具体有哪些，枚举为什么可以作为其键值（最后的比较会解释）？ pair和mappair pair是c++定义好的一个类模板的结构体，使用需要加上头文件 pair意如其名，就是一对，用于一对数据的集合，这个数据结构就十分有利于后面的键值和关键字值的集合，进一步实现各类查找表，map的基本单元就是pair构成的。 pair的部分源码 12345678910111213template &lt;class T1, class T2&gt;struct pair{ typedef T1 first_type; //对第一个类型的别名 typedef T2 second_type; //对第二个类型的别名 T1 first; //第一个数据成员 T2 second; //第二个数据成员 pair(): first(T1()), second(T2()) {} pair(const T1&amp; a, const T2&amp; b): first(a), second(b) {}} 最常用的就是pair的俩个可访问的first和second 【声明方式】 1std::pair&lt;第一种数据类型，第二种数据类型&gt; 变量名; 【简单的使用】 123456789101112131415#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;string&gt;using namespace std;int main(){ pair&lt;int, int&gt; test; stu.first = 1; stu.second = 2; cout &lt;&lt; stu.first &lt;&lt;endl; cout &lt;&lt; stu.second&lt;&lt;endl; return 0;} 初始化 第一种就是默认构造函数，数字类型数据初始化为0，字符串初始化为空， 如果是类的话从上面提供的部分源码看，进一步调用类的构造函数 1pair&lt;int,int &gt;test; 第二种就是拷贝构造函数，必须是同类型的就是了 12pair&lt;int,int &gt;test（pair_copy）;pair&lt;int,int &gt;test=pair_copy; //这俩种形式调用的都是赋值构造函数，不是=的运算符重载 第三种就是构造函数传入对应的俩个值了,就是构造函数重载 1pair&lt;int,int&gt;test(1,1); 还能比较大小就是实现了运算符重载 先比first，first相等再比second（前提是对应的数据类型必须相同） 字符串的比较大小的规则在string可以去了解，至于类可能就是取决于类的运算符重载了 1pair_1&gt;pair_2; make_pair() 这就是标准库的提供的一个函数，用于创建一个临时的pair 功能：**make_pair函数接收两个参数，然后它会将这两个参数来创建pair对象** 1map.insert(make_pair&lt;int,int&gt;tmp(1,2));//这样就可以在图直接插入一个临时创建的pair了 map 首先在STL的容器类型上，map属于“关联式容器” 所谓关联式容器，就是每个元素都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构可能是红黑树，也可能是哈希表，然后按照其键值key大小，以某种特点规则将这个元素放在一个合适的位置。 一般而言，关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率，也就没有一般序列式的容器的头尾元素 map就是以pair为基本单元，结构上采取红黑树形成的一个动态查找表。 此时pair的俩个元素就有区别了pair&lt;键值，实值&gt; 注意：map不允许重复的键值出现 #/## 插入 V老师的没有使用插入函数，而是使用索引去实现插入的功能， 虽然使用的是unordered_map（基于哈希表实现），但是和map大概原理也大差不差 后面也会分析如何实现【】访问操作 【函数原型】 从第一个插入函数参数我们可以直到调用map的insert参数是一个pair类型，其次注意其返回值是一个pair&lt;迭代器，bool（是否插入成功）&gt; 所以要注意的就是参数和返回值。 12345678910111213141516#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;int,int&gt; dic; dic.insert(make_pair(1,1)); //正常的插入操作 //插入的返回值是一个pair，first是迭代器（指向插入的指针），second是bool显示是否插入成功 cout &lt;&lt; (dic.insert(make_pair(3, 3))).second; //调用返回的pair的second，显示为1，表示插入成功 cout &lt;&lt; (dic.insert(make_pair(2, 2))).first-&gt;second;//使用first迭代器指向插入对象的second，显示为2 return 0;} 常用的插入方式如下 12345678910//方式1pair&lt;int,int&gt;test=(1,1);map.insert(test);//方式2map.insert(make_pair(1,1));//根据插入函数2，起始发现可以使用迭代器插入，但是对于有序的map来说必然要涉及到重排什么的，我觉得我一般也用不上iterator insert (const_iterator position, const value_type&amp; val);//根据插入函数三，是c++11新提供的可以一次性插入多个值，我觉我也用不上，乐void insert (initializer_list&lt;value_type&gt; il); 迭代器map支持迭代器，表明我们可以利用迭代器遍历甚至是for 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;int,int&gt; dic; dic.insert(make_pair(1, 1)); dic.insert(make_pair(2, 1)); dic.insert(make_pair(3, 1)); dic.insert(make_pair(4, 1)); dic.insert(make_pair(5, 1)); map&lt;int, int&gt;::iterator begin = dic.begin(); map&lt;int,int&gt;::iterator end=dic.end(); //迭代器循环 while (begin != end) { cout &lt;&lt; begin-&gt;first; //既可以用指针访问 cout &lt;&lt; (*begin).first; //也可以用*，再用.first访问 begin++; //显示了1122334455 } //for循环的使用也是可以的，直接获取对方的引用 for (auto&amp; pair : dic) { cout &lt;&lt; pair.first; //显示12345 } return 0;} 那么现在就有一个问题：可以通过map的迭代器改变map的元素内容吗？ 如果是想修改键值(key)是不行的。还是和set一样的原因：map元素的键值关系到map元素的排列规则。任意改变map元素的key将会严重破坏map组织。 但如果想要修改元素的实值(value)，那么是可以的。因为map元素的实值value并不影响map的排列规则 这里显示键值是const，不可修改 operator【】对于上面的实值遍历我也可以这么写 1234567891011121314151617181920212223#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;int,int&gt; dic; dic.insert(make_pair(1, 1)); dic.insert(make_pair(2, 1)); dic.insert(make_pair(3, 1)); dic.insert(make_pair(4, 1)); dic.insert(make_pair(5, 1)); cout &lt;&lt; endl; for (int i = 1; i &lt; 6; i++) { cout &lt;&lt; dic[i]; } //显示了11111 return 0;} 不难看出对于map类函数，键值可以直接当做索引直接访问 mapped_type就是对应的实值，key_type就是对应的键值 【】的重载以键值为参数，返回对实值的引用 但是V老师明明是在创建新的对象，为什么可以直接赋值创建新对象呢呢？ 上面的图像说明了原理，我们之前也分析了insert函数的返回值是$pair&lt;iterator,bool&gt;$ 先调用map当前的insert函数（this-&gt;insert()） 如果有重复的键值就会插入失败，返回pair&lt;对应位置的迭代器，false&gt;,返回pair的first（要查找的pair）的second（实值）。 如果没有重复的键值显然插入成功了，返回pair&lt;新插入的点的迭代器，true&gt;，返回pair的first（新创建的pair）的second。 那么访问的也不过俩种情况 键值key已经在树里，那么就返回树里面key所在结点的迭代器 键值key不在树里，那么就返回新插入key所在结点的迭代器（注意没有键值就新插入一个了） 注意观察函数的返回值是引用，表明我们可以修改对应的实值value。 从而大v老师的创建也就合理，因为对应的键值没有，所以在访问的时候已经创建了。 虽然大v老师使用的是无序图(哈希表实现)的，但实现类似不妨碍我们去理解。 （对于枚举作键值起始也很好理解，枚举ResID是一种类型，就像int，里面的实际的对象就是键值，就像1，2 但是对于哈希表的键值，这里枚举能使用的原因也比较特殊） 123texture_pool[ResID::Tex_Player] = IMG_LoadTexture(renderer, &quot;resources/player.png&quot;);texture_pool[ResID::Tex_Archer] = IMG_LoadTexture(renderer, &quot;resources/tower_archer.png&quot;);texture_pool[ResID::Tex_Axeman] = IMG_LoadTexture(renderer, &quot;resources/tower_axeman.png&quot;); 常见的其他map函数方法取值Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。 []实现原理我们也解释了,不难理解为什么不会 1ID_Name.at(2016)； 容量查询123456789101112// 查询map是否为空bool empty();// 查询map中键值对的数量size_t size();// 查询map所能包含的最大键值对数量，和系统和应用库有关。// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了size_t max_size();// 查询关键字为key的元素的个数，在map里结果非0即1size_t count( const Key&amp; key ) const; // 删除1234567891011// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器iterator erase( iterator pos )// 删除一定范围内的元素，并返回一个指向下一元素的迭代器iterator erase( const_iterator first, const_iterator last );// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1size_t erase( const key_type&amp; key );// 清空map，清空后的size为0void clear(); 交换12// 就是两个map的内容互换void swap( map&amp; other ); 顺序比较12// 比较两个关键字在map中位置的先后key_compare key_comp() const; 查找1234// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器// 根据map的类型，返回的迭代器为 iterator 或者 const_iteratoriterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; unordered_map和map简单比较（使用方法类似，只说说不同）首先最大的区别就是底层的实现逻辑不同 map： 优点： 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高 缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间 适用处：对于那些有顺序要求的问题，用map会更高效一些 unordered_map： 优点： 因为内部实现了哈希表，因此其查找速度非常的快 缺点： 哈希表的建立比较耗费时间 适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 有一点我比较在意就是关于键值的问题 对于红黑树的有序排序必然少不了比较，而哈希表的键值映射到索引的过程如何转换 对于map来说 对于提供键值的类型虽然没有限制，但是对于一些自定义的类，必须有比较运算符的重载（&gt;,&lt;,==,） 不然无法在红黑树实现有序的排序，下面的方式就会报错 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct num{ string tmp; int a; int b;};int main(){ map&lt;num,int&gt; dic; num tmp1; tmp1.tmp = &quot;lalla&quot;; tmp1.a = 1;tmp1.b = 2; num tmp2; tmp2.tmp = &quot;lalla&quot;;tmp2.a = 1;tmp2.b = 2; dic.insert(make_pair(tmp1, 2)); dic.insert(make_pair(tmp2, 2)); //会显示失败，因为没有定义重载运算符 return 0;} 对于unordered_map来说 键值只能是int或者string类型，因为哈希表是一个映射的过程 所以显然类无法通过函数实现映射，只能使用其哈希内部定义的整型和字符串 对于大v老师的使用来说，恰巧枚举是可以视为整型数据的，所以可以作为unordered_map的键值，这一点也是十分巧妙。","link":"/articles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map&&unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"简单的单例模式实现","text":"跟着大v老师学习的时候学习到了这个设计模式，因为马上要去gamejam，学长跟我说滥用单例就好了（bushi，就因此感兴趣了解一下，顺带巩固一些C++语法知识点,学的时候注意不到，用的时候就印象深刻了。 接下来我会先对照课本复习一下类内的静态变量，然后对照网上的单例文章和课程代码写点东西(因为锁和线程我不了解，就基于大V老师教的简单写写) 类内的静态成员静态数据成员静态数据成员：类的静态数据成员拥有一块单独的存储区，所有这个类的对象的静态数据成员都共享这一块空间（这就像银行所有的账户都享有同样的利率）。但静态数据成员是属于类的，他的名称只在类的范围内有效（就是实例化的对象无法调用），并且可以是私有的也可以是公有的，这样可以避免其他全局函数的干扰。 定义： 12345class SavingAccount{private: static double rate; //定义了一个私有静态成员变量} 注意：静态数据成员属于类，不属于实例化的对象，从而在实例化对象为对象分配空间时并不包含静态数据成员的空间 静态数据成员的空间必须单独分配且只分配一次，为静态数据成员分配空间成为静态数据成员的定义（一般在cpp实现文件中） 1234//SavingAccount.cpp//作用域::静态成员变量名double SavingAccount::rate=0.05; //为rate分配空间，并赋予了初值，若没有这个定义，链接时会报错 由于静态数据成员是属于类的，因此可以通过作用域运算符用类名直接调用，如”类名::静态数据成员名“。 从每个对象的角度来看，似乎是实例化对象的一部分，可以像普通的成员一样用对象引用$Account1.rate$。但是指向的都是同一块空间。 静态成员函数静态成员函数：专门用于操作静态数据成员。 于普通函数一样就是在声明的前面加上static，静态成员函数的定义既可以写在类内，也可以写在类外。（在类外定义的时候不需要加static） 例如，我要修改savingaccount的rate 1234static void SetRate(double newRate){ rate=newRate;} 注意：静态成员函数是为类服务的，从而实例化对象调用的时候静态函数不会像普通函数一样有隐式的$*this$​指针可以访问实例化对象内的普通成员变量和普通成员函数。 （大概率静态成员函数和静态数据成员变量都存放在一个存储空间且有联系）静态成员函数只能调用静态数据成员和静态成员函数。 调用的话，有实例化对象可以实例化对象调用 1Account.SetRate(0); 就算没有实例化对象，也可以使用类名来调用，”类名::静态成员函数名（）“ 1SavingAccount::SetRate(0); 静态常量数据成员当有时候整个类需要共享一个常量，就可以用static const来声明。 首先区分一下常量数据成员和静态常量数据成员 常量数据成员是针对不同的实例化对象的，每个实例化对象的常量数据成员各不相同，const声明 静态常量数据成员是属于整个类，所有实例化对象都一样，是static const声明的 初始化： 普通数据成员可以在对象定义的构造函数初始化 静态数据成员实在静态数据成员定义的时候初始化，一般是在类外定义。 常量静态数据成员竟然可以在类内定义的时候初始化（只能是整型），注意不是构造函数，是在类内声明的时候直接赋值 1234class SavingAccount{ static const int rate=10;}//类似这样 注意：如果静态常量数据成员是非整型，则不能在类内赋初值，在类中只能声明，在类外定义 1234static const double st; //类内声明//类外定义的时候可以不写static,和函数一样const SavingAccount::st=1.5; 所以不管什么还是建议在类外定义，以防记混报错。 单例化的一些概念 简单看了一下，不太懂锁和线程这方面的知识点，所以就对着文章简单写点吧，后面了解了有机会再细说 1. 什么是单例模式 单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。 2. 单例模式的类型单例模式有两种类型： 懒汉式：在真正需要使用对象时才去创建该单例类对象 饿汉式：在类加载时已经创建好该单例对象，等待被程序使用 懒汉式单例模式：在首次获取实例时创建。这种方式在多线程环境下存在线程安全问题，需要通过加锁或双重检查等方式解决。 12345678910111213141516public class Singleton { private static Singleton singleton; private Singleton(){} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; }} 饿汉式单例模式：在类加载时就创建实例。这种方式在多线程环境下是线程安全的，但可能会浪费内存空间。 123456789101112public class Singleton{ private static final Singleton singleton = new Singleton(); private Singleton(){} public static Singleton getInstance() { return singleton; }} 后面的我也不懂了，有兴趣就去csdn去看看吧 原文链接 课程代码的单例实现（Manager类）这个gameManager和Manager关系就感觉有点绕 就像大V老师说的通过继承的方式，让子类能自动的形成构造-&gt;就对基类引入了模板。 通过对基类的单例实现，然后将子类是继承基类（用子类作为模板参数传入的基类）实现。 我的理解就如同下图 这样就是实现了继承子类都可以实现单例的功能 先看manager.h的内容吧 123456789101112131415161718192021222324252627282930313233#ifndef _MANAGER_H_#define _MANAGER_H_template&lt;typename T&gt;class Manager{public: //静态成员函数只可以修改静态数据成员和静态成员函数 //通过静态成员函数instance（）可以实现单例的构造 static T* instance() { if (!manager) //如果静态数据成员（单例对象）未实例化，则实例化 manager = new T(); return manager; //返回静态成员指针 } ~Manager()=default;private: static T* manager; //声明静态成员变量 protected: //将构造函数访问特性设置为protected，那么就无法再外界构造对象，保证了单例化的唯一性 Manager() = default; //删除复制构造函数和=号的运算符重载，也是为了防止外界构造对象 Manager(const Manager&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete;};//将单例的对象设置为静态数据成员，这里是静态数据成员的定义，换种角度就是为其分配空间，不然会报错template&lt;typename T&gt;T* Manager&lt;T&gt;::manager = nullptr;#endif // ! _MANAGER_H_ 注意：以上都是模板参数，最后生成的静态数据成员都是子类对象，一些细节也在里面说明了。 我们再来看看**”game_scene.h”** 12345678910111213141516#ifndef _GAME_MANAGER_H_#define _GAME_MANAGER_H_#include &quot;manager.h&quot;class GameManager:public Manager&lt;GameManager&gt;{ //因为在继承的时候会调用GameManager类的构造函数，所以需要声明一下友元 friend class Manager&lt;GameManager&gt;;protected: GameManager(){} ~GameManager(){}};#endif // !_GAME_MANAGER_H_ 最后看main.cpp 1234567891011#define SDL_MAIN_HANDLED#include&lt;iostream&gt;#include &quot;game_manager.h&quot;int main(int argc,char** argv){ //这就很好理解了，instance接受的其实就是单例化静态成员的那块空间的地址，这样main函数里就可以用了 GameManager* instance = GameManager::instance(); return 0;} 大体上课程就是如此实现单例化和继承单例化功能，从而保证对象的唯一性。","link":"/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"奥日与萤火森林2","text":"玩奥日有感（真随笔）剧情上 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图解锁了地底下和森林的碎片唤醒了底下的蜘蛛（被腐朽吞噬了心智）夸洛克牺牲了自我换回碎片 剧情就不得不提到npc了莫基——路人角色，大大小小的任务都有承担，森林的原住民算是库克——地图提供者猴子——推动剧情，教会武器方面技能商人——交易升级技能夸洛克——沼泽的庇护神工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器 玩法上在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。在角色系统我会介绍这些对玩法的贡献 主要是——场景，场景关卡设置，物品和玩法剖析 场景的关卡前期的最大关卡就是【1】找到散落的楔石打开石门小的关卡【2】拖拽石头来阻挡机关和帮助跳跃还有类似司机挡位的机关——触发一些机关，打开石门等等【3】还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏 场景物品藤条——帮助跳跃竖直木棒——陷阱悬停水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了羽毛——还有库和奥日的配合玩法—— 补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯 玩法其实有的已经融合在以上或者以下的分析里面主要探索，打斗剧情的玩法——对话打斗boss等boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣 场景第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景 从角色系统上分析主要分为四个部分 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条） 武器+主动技能系统从光剑到弓箭到重锤，技能则有光之箭和回血等评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。光剑——可以打碎一些木板障碍物例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速重锤——可以打碎石板光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）其他目前武器目前没有看到对地图探索的作用，有再补充 不可见的被动技能例如二连跳抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深 课拆卸购买升级的被动技能首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级技能框则是探索地图一步一步的去扩展讲几个印象比较深的技能:攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行三连跳——好吧也是默认了，不仅帅而且探索地图确实方便其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧 （4）","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%A3%AE%E6%9E%97%E4%BD%93%E4%BC%9A/"},{"title":"笼中窥梦","text":"笼中窥梦心得第一次玩到这个游戏我就想到了初中玩的画中世界，视觉错觉的艺术美与打动人心且朦胧的故事感，很平静却又是如此吸引人。感觉就像是在品味人生，同时享受着美妙的艺术。 从叙事性上看吧，这类的游戏没有明确表述主线，都是以一种很朦胧大概的方式，只言片语的描绘故事，这就像一千个读者一千个哈姆雷特，我觉得这种叙事方式却给了玩家最好的体验。叙事主要是从游戏的场景，拾起的相片，和游戏交互推动的。从我第一次简单通关的角度描绘我眼中的故事：大体上是简单的讲述了一个人的一生，从小然后成长为一位研制武器的科学家，颇有成果但是在战乱后他同样参军，流离失所，于硝烟中漂泊，见识到了他的武器在战争中给无数人带来的苦难，一路走来，他见证了多少美好的过去被战火所毁灭，春去秋来，撑到了战争结束的一天，但是他却孑然一身，陷入了深深的自责与内疚，他走不出这段阴影，更对不起过去小时候的自己，看到无数因为战争而生出的坟墓，时常到教堂去忏悔自己罪恶（这个教堂是当时的一个场景，经理三个阶段，战争前，被毁灭，被重建，也许也暗示主线的过程）。但是在一步步中他慢慢打开了心结，离开了医院，回到了过去的小屋接纳当下的自己。最让我印象深刻的场景就是最后，过去小时候的照片中的自己与今天的自己被拼接在一起，俩个人面面相觑，但最后成长的自己将小时候的自己紧紧抱入了怀中，说真的那个时候真的很感人。最后的最后，场景再次回到了游戏开始的时候。怎么说呢，笼中窥梦，确实在一个一个个镜面里窥看一个人的一生，也许是梦，也许是一个人的故事，而且视觉错位的艺术玩法和诗意平静的叙事方式真的很打动人吧，最后回到故事的开始，是梦醒，更让我感受到这个游戏就像梦一样。人的一生坎坎坷坷，跌跌撞撞，最美好的故事的结局还是走到故事的起点吗？ 游戏的场景上，每一个场景都蕴含了主角故事的较为关键的节点，同时一些场景也在隐喻着一些事情，举个例子其中一个场景是启动导弹的发射，于是故事的叙事开始从战争的角度开始描述，还有前面的教堂的变换贯穿了战争和战后，从长满杂草到被战火摧残再到重建成为人们心里的寄托，也许反应主人公的心境吧。 在玩法上，确实很有创新，利用场景的拼接去描述一个一个故事。难度上不是很大，高亮是当下要用的，浅亮的重要但是不是当下用，而且可以选择提示和演示视频（我中间确实有几次卡关了），一方面是可利用的游戏场景他不会标记，你可能想不到，另一方面有的交互是一连串触发有时间的限制，影响最深的就是一个炮弹滚了大概三四个场景才完成最终的目的，但整体看下来不是很难，有些地方有小彩蛋来解锁成就。虽难脑袋不是很适合解密，但是视觉错觉的艺术玩法和平静诗意的叙事很触动我，也许是生活缺少了感动（我承认我情商确实低…….）在音乐上，额，几乎没有背景音乐，只有互动场景的音效，我觉得是不是可以配上一点适合氛围的音乐（虽然只有俩个人做出来确实不容易），但是当下这个作品已经近乎完美了。 漫谈 ：提到游戏，我更加喜欢像这样叙事朦胧却又真的打动人心，仅仅通过场景去体会这种故事。我玩的游戏不多，但是像这样印象深刻就是画中世界和地狱边境。画中世界的故事梗概记不住了，美术相当出色，解密做的也很好，地狱边境的内容比较清楚，好像是描述一家人遭遇了车祸，然后弟弟在地狱只有黑白的场景一路寻找他的姐姐，相较于这个游戏那个故事更有起伏，因为有怪物的存在，但是最后他终于姐姐相会了（也许是俩个人最后都离开了），同样有姐姐的我当时也是印象深刻，生离死别，却又在最后看见了你最后一眼，真的是。。。。 最后说一说笼中窥梦的作者，感兴趣的可以上b站搜《钱从哪来》的栏目，有一期就采访了他们的团队，俩个人，一个程序策划，一个美术，打磨出了这个作品。独立游戏制作的不易，可以从这个节目看到。有一期还是采访了我们学校的一个团队，放弃读研，放弃offer，几个人出来做游戏，可是才发现做独立游戏的道路上确实更多窘境和不易——《成土市的我》《什么鸟都》 看到一个朋友圈是“珍惜身边做独游的人吧，非要说的话那就是爱。” 最后用笼中窥梦的作者的话，“祝愿你做一个好梦”","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E7%AC%BC%E4%B8%AD%E7%AA%A5%E6%A2%A6%E5%BF%83%E5%BE%97/"},{"title":"欢迎来到我的博客，见证我的成长","text":"在此特别感谢voidMatrix老师和从零开始的C++游戏开发的群友的帮忙！！ 希望群友们能够在今后的日子里互相帮助互相进步，也祝V老师事业蒸蒸日上！！","link":"/2024/06/03/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%A7%81%E8%AF%81%E6%88%91%E7%9A%84%E6%88%90%E9%95%BF/"},{"title":"","text":"计时器[TOC] 游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。 计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。 我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#ifndef _TIMER_H_#define _TIMER_H_#include &lt;functional&gt;class Timer{public: Timer() = default; ~Timer() = default; void restart() { pass_time = 0; shotted = false; } void set_wait_time(int val) { wait_time = val; } void set_one_shot(bool flag) { one_shot = flag; } void set_callback(std::function&lt;void()&gt; callback) { this-&gt;callback = callback; } void pause() { paused = true; } void resume() { paused = false; } void on_update(int delta) { if (paused) return; pass_time += delta; if (pass_time &gt;= wait_time) { if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) callback(); shotted = true; pass_time = pass_time-wait_time; } }private: int pass_time = 0; int wait_time = 0; bool paused = false; bool shotted = false; bool one_shot = false; std::function&lt;void()&gt; callback; }; #endif // !_TIMER_H_ 我们先从函数设置上分析功能 重置计时器（restart） 是否选择重复触发（set_one_shot） 设置重复触发的间隔时间（set_wait_time） 回调函数的设置(set_callback) 计时器暂停(pause) 计时器继续(resume) 计时器数据更新(on_update) 从以上我们就简单看出了计时器的基本功能 状态的转换（单触发还是多次触发） 计时的暂停和继续 每次累计时间到达后执行的回调函数 回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作 类似lambda函数，后面分析函数会具体说明 函数实现的简单分析成员变量1234567private: int pass_time = 0; //单次累计时间 int wait_time = 0; //间隔时间 bool paused = false; //计时器是否暂停 bool shotted = false; //是否触发的状态量 bool one_shot = false; //是否单次触发，false为循环触发 std::function&lt;void()&gt; callback; //回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还 之后还会用到LAMBDA函数，来作为实参传输 restart（）12345void restart() { pass_time = 0; //累计时间清零 shotted = false; //触发状态量回归未触发状态 } 每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据 set_on_shot()1234void set_one_shot(bool flag) //是否单次触发 { one_shot = flag; //false为循环触发 } 有的游戏应用场景下只需要计时器触发一次 例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次） set_wait_time（）1234void set_wait_time(int val) //设置触发的时间间隔 { wait_time = val; } 循环计时需要设置间隔时间 例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔 set_callback()1234void set_callback(std::function&lt;void()&gt; callback) //这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 { this-&gt;callback = callback; } 传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针） 例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex=false;的逻辑 后面分析游戏实例会讲解 pause()&amp;&amp;resume()123456789void pause() { paused = true;}void resume() { paused = false; } 计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值 on_update()1234567891011121314void on_update(int delta) { if (paused) //先检查计时器是否处于暂停状态 return; pass_time += delta; //若不暂停，则计时 if (pass_time &gt;= wait_time) //如果到达了触发间隔且未暂停 { if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) //前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数 callback(); shotted = true; pass_time = pass_time-wait_time; } } 计时器数据更新的关键就是 何时触发和什么条件触发回调函数 （由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键） 12if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) callback(); 首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0） 其次就是循环触发（那就不考虑shotted状态了，时间到了就触发）和单次触发且还处于未触发状态（shotted为false） 不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数 关于回调函数和函数指针，lambda函数的分析函数指针 指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针 定义格式：返回类型 （*指针变量）(形式参数表) 12int (*point)(); //指向一个参数，返回值为int的函数int (*point)(int); //指向一个有int参数，返回值为int的函数 注意：声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高 指针的赋值可以是：指针变量名=函数名 1point=f1； 函数指针主要有俩个用途：作为函数的参数（就是作为形参），和实现菜单 作为函数的参数 123456template&lt;class T&gt;void sort(T a[],int size,bool(*f)(T,T)){ //冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较 bool is_bigger=f(a,b)；} 为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入 菜单的实现（其实是函数指针数组的使用） 12345678int main(){ //假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数 void (*menu[6])()={NULL,add,erase,modify,printSalary,printReport}; int n; cin&gt;&gt;n; menu[n];} 就是理解函数指针也是有数组的，让函数的接口变得更见简答易用 lambda函数 看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量 表达形式：**[捕获列表] （形式参数表）-&gt;返回类型{函数体}** 1[](int x,int y)-&gt;int{return x+y}; 有俩个形参，返回类型为int 注意：当返回类型很明确时，lambda函数可以不用尾置指定返回类型 例如： 1[](int x,int y){return x+y}; 返回类型很明确不需要尾置，这也是正确的，也是比较常用的 与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称捕获 常见的捕获有一下几种形式 [x]:以值捕获的方式捕获变量x [=]:以值捕获的方式捕获所有变量 [&amp;x]：以引用捕获的方式捕获变量x [&amp;]:以引用捕获的方式捕获所有变量 回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。 如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。 当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。 这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面 12345678int main(){ int x=15; auto f=[&amp;x](int y)-&gt;int {return (++x)+y;}; x=20; f(5); cout&lt;&lt;x;} 【&amp;x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到 回调函数 在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。 使用functional库的回调函数，可以实现以下功能： 将函数作为参数传递给其他函数，以便在需要的时候调用。 在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。 在函数式编程中，可以使用回调函数来实现高阶函数的操作。 定义：std::function&lt;返回类型（参数类型列表）&gt; 回调函数名 1std::function&lt;void(int)&gt; callback 表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装） 注意：function也是定义在标准函数库里的，所以要声明域名std 基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器 关于植物明星大乱斗中的计时器逻辑分析大体本游戏使用了一下的计时器 123456789Timer timer_invulnerable; //无敌状态定时器Timer timer_invulnerable_blink; //无敌状态闪烁定时器，用于不同序列帧的切换功能Timer timer_attack_cd; //普通攻击冷却定时器Timer timer_run_effect_generation; //跑动粒子特效发射定时器Timer timer_die_effect_generation; //死亡特效例子发射器Timer timer_cursor_visibility; //玩家光标指示器可见性定时器 无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态 闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、 普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成 跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片） 死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成 玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示 例子： 无敌状态定时器1234567891011121314151617181920212223242526272829Timer timer_invulnerable; //无敌状态定时器Player() { //无敌状态定时器的初始化设置 timer_invulnerable.set_wait_time(750); //触发事件间隔750毫秒，0.75秒 timer_invulnerable.set_one_shot(true); //单次触发 timer_invulnerable.set_callback([&amp;]() //设置回调函数 { is_invulnerable = false; });} void on_update() { ..... timer_invulnerable.on_update(delta);//更新 move_and_collide(); //检测触发函数 }void make_invulnerable(){ is_invulnerable = true; //受击状态量改为true timer_invulnerable.restart(); //计时器重置，shotted改为false，事件到达后is_vulnerable改回false} 简单分析一下这里的回调函数 [&amp;](){is_invulnerable=false;} 以引用捕获的方式获取类的局部变量，没有形参，函数主体 大体流程就是这样子的 总结： 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。 相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解 植物明星大乱斗教程","link":"/2024/06/14/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E5%88%86%E6%9E%90/"}],"tags":[{"name":"c++语法","slug":"c-语法","link":"/tags/c-%E8%AF%AD%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"csv","slug":"csv","link":"/tags/csv/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"塔防课程","slug":"塔防课程","link":"/tags/%E5%A1%94%E9%98%B2%E8%AF%BE%E7%A8%8B/"},{"name":"游戏心得","slug":"游戏心得","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"}],"categories":[{"name":"c++语法","slug":"c-语法","link":"/categories/c-%E8%AF%AD%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"json","slug":"json","link":"/categories/json/"},{"name":"csv","slug":"csv","link":"/categories/csv/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"游戏心得","slug":"游戏心得","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"},{"name":"植物明星大乱斗","slug":"植物明星大乱斗","link":"/categories/%E6%A4%8D%E7%89%A9%E6%98%8E%E6%98%9F%E5%A4%A7%E4%B9%B1%E6%96%97/"}],"pages":[]}