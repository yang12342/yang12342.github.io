{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/06/03/hello-world/"},{"title":"欢迎来到我的博客，见证我的成长","text":"","link":"/2024/06/03/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%A7%81%E8%AF%81%E6%88%91%E7%9A%84%E6%88%90%E9%95%BF/"},{"title":"奥日与萤火森林2","text":"玩奥日有感（真随笔）剧情上 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图解锁了地底下和森林的碎片唤醒了底下的蜘蛛（被腐朽吞噬了心智）夸洛克牺牲了自我换回碎片 剧情就不得不提到npc了莫基——路人角色，大大小小的任务都有承担，森林的原住民算是库克——地图提供者猴子——推动剧情，教会武器方面技能商人——交易升级技能夸洛克——沼泽的庇护神工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器 玩法上在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。在角色系统我会介绍这些对玩法的贡献 主要是——场景，场景关卡设置，物品和玩法剖析 场景的关卡前期的最大关卡就是【1】找到散落的楔石打开石门小的关卡【2】拖拽石头来阻挡机关和帮助跳跃还有类似司机挡位的机关——触发一些机关，打开石门等等【3】还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏 场景物品藤条——帮助跳跃竖直木棒——陷阱悬停水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了羽毛——还有库和奥日的配合玩法—— 补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯 玩法其实有的已经融合在以上或者以下的分析里面主要探索，打斗剧情的玩法——对话打斗boss等boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣 场景第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景 从角色系统上分析主要分为四个部分 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条） 武器+主动技能系统从光剑到弓箭到重锤，技能则有光之箭和回血等评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。光剑——可以打碎一些木板障碍物例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速重锤——可以打碎石板光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）其他目前武器目前没有看到对地图探索的作用，有再补充 不可见的被动技能例如二连跳抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深 课拆卸购买升级的被动技能首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级技能框则是探索地图一步一步的去扩展讲几个印象比较深的技能:攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行三连跳——好吧也是默认了，不仅帅而且探索地图确实方便其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧 （4）","link":"/articles/yang/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%A3%AE%E6%9E%97%E4%BD%93%E4%BC%9A/"},{"title":"","text":"二叉查找树 先附上完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157template &lt;class KEY,class OTHER&gt;struct SET{ KEY key; //关键字信息 OTHER other; //和其他信息};//二叉查找1.左子树不空，则左子树中的所有节点都比根节点小//右子树的所有节点都比大//他的左右子树也是二叉查找树template&lt;class KEY,class OTHER&gt;class dynamicSearchTable{public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; virtual void remove(const KEY&amp; x) = 0; virtual ~dynamicSearchTable() {};};template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root;public: BinarySearchTree(); ~BinarySearchTree(); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x);private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); void remove(const KEY&amp; x, BinaryNode*&amp; t); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; void makeEmpty(BinaryNode* t);};//在这段代码中，BinaryNode结构体中包含了一个SET结构体的数据成员data。在find函数中，当返回t指针时，将其强制转换为SET&lt;KEY, OTHER&gt;* 类型。// 由于BinaryNode结构体中的data成员是一个SET结构体，因此t指针指向的内存地址实际上是SET结构体的起始地址。// 通过强制转换，可以将指向BinaryNode的指针t转换为指向SET的指针，这样就可以直接访问SET结构体中的key和other成员。// 需要注意的是，这种强制转换是一种不安全的操作，需要确保在转换前已经明确了t指针实际指向的是SET结构体的数据成员。template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) //如果是不存在或者就是当前的节点 return (SET&lt;KEY,OTHER&gt;*)t; //找到就返回这个指针 if (x &lt; t-&gt;data.key) //如果小于则向左找 return find(x.t-&gt;left); else return find(x, right); //大于则向右找}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); //若根节点不存在，则直接存进去 else if (x.key &lt; t-&gt;data.key) //若小于当前节点则向左查 insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) //大于则向右查 insert(x, t-&gt;right); //等于的情况直接退出不干，二叉树的插入必然在}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}/** 删除大体是这个思路为了保证树的结构不变，主要分三种情况* 1.如果这个删除节点没有度数为0，很简单删除就好了* 2.只有一个子节点，吧字节点复制上去，把字节点删除* 3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数* 其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点）* 对于这题我们假设向右子节点寻求最接近的值*/template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ if (t == NULL)return; //不可能删除空节点哈 if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); //先找到存放相应数据的节点 else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) //这里是找到了 { //如果左右都有子节点 BinaryNode* tmp = t-&gt;right; //选择右枝 while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //一直找的右枝的左子节点直到这节点没有左子节点 t-&gt;data = tmp-&gt;data; //把这个值赋值到要替换的节点 remove(t-&gt;data.key, t-&gt;right); //这样要删的逻辑就是替换的点，递归的形式处理,主要是针对这节点有右子树 //因为我们整体的逻辑是往右边找的而我们替换的字节点恰好没有左节点，最多只有右节点 } else { BinaryNode* oldNode = t; //注意我们这里的指针都是引用，修改的是父节点的left or right t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; //如果这个没有俩个节点，只有一个或者没有， //如果左子节点为空，就把右子节点替换t指针，不然就是放左子节点，即使也放 delete oldNode; //那原本t对应的节点删了就好了，因为t对应的的节点被替换了 } //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL;}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; //删的话就是前序遍历删除，从上往下 makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root);}int main(){ return 0;} ##前提组成 template &lt;class KEY,class OTHER&gt; struct SET { KEY key; //关键字信息 OTHER other; //和其他信息 }; 123456789101112131415 这是基本的数据元素 分别包括**键值**key和**其他值**value（就像字典里面对应的查找关键和词语解释）- ~~~c++ template&lt;class KEY,class OTHER&gt; class dynamicSearchTable { public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; //查找目标元素，返回值为指针 virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; //插入功能 virtual void remove(const KEY&amp; x) = 0; //显然是删除功能 virtual ~dynamicSearchTable() {}; //析构函数 }; 这就是二叉查找树的父类**动态查找表**，也可以看作一个模板而已，提供了基础的一个动态查找的基本功能模板 ##动态二叉树 动态二叉树的主体类函数 1234567891011121314151617181920212223242526template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root;public: BinarySearchTree(); //构造函数 ~BinarySearchTree(); //析构函数 SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数（公有，面向使用者） void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有，面向使用者） void remove(const KEY&amp; x); //删除函数（公有，面向使用者）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); //查找函数（私有，面向公有调用函数） void remove(const KEY&amp; x, BinaryNode*&amp; t); //插入函数（公有，面向公有调用函数） SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; //删除函数（公有，面向公有调用函数） void makeEmpty(BinaryNode* t); //清空函数}; 树的节点分析： 123456789struct BinaryNode { SET&lt;KEY, OTHER&gt;data; //本体的数据 BinaryNode* left; //左子节点的指针 BinaryNode* right; //右子节点的指针 BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, //节点的构造函数，可以直接设定三个成员 BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 注意：后面经常会用到公有函数调用私有函数，虽然名称一样，但一个面向使用者，私有的面向共有的函数调用内部 12345void remove(const KEY&amp; x) //删除函数（公有，面向使用者）{ remove(x,root); //这里调用的就是私有函数}void remove(const KEY&amp; x, BinaryNode*&amp; t); //这就是私有函数的接口和实现 #接下来分析函数实现 构造函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL; //简单初始化了一下根节点} makempty 主要还是递归循环删除，采用了前序遍历的思想 12345678template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; //递归终止的条件（删到了空节点） makeEmpty(t-&gt;left); //正常步骤先删左节点，往下递归 makeEmpty(t-&gt;right); //再删右节点，往下递归 delete t; //删除自己 }//最后就删除了所给节点和节点的所有子节点 拓展：其实最近刷题还看到了一种实现方法就是入队和出队在这里 优点：就是摆脱了递归的对于空间的大量调用，利用循环和队列实现（更多是在链表使用的方法） 其实这是层序遍历的使用方法，只是用这个实现了层序遍历的删除方式 123456789101112131415&gt;**自己拓展的，不是范例的**&gt;Queue&lt;BinaryNode*&gt; queue; //存放节点指针的队列&gt;template&lt;class KEY, class OTHER&gt;&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)&gt;{queue.enqueue(t); //先把根节点放入队列 while(t.isempty()) //终止条件：检查队列是否为空，不空则继续进行 { BinaryNode* t=queue.dequeue(); //出队队列的第一个节点 if(t-&gt;left!=nullptr)queue.enqueue(t-&gt;left); //左子节点有就放进队列，没则不处理 if(t-&gt;right!=nullptr)queue.enqueue(t-&gt;right); //同理 delete t; //然后删除自己 }&gt;} 析构函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root); //就从root开始删除，很简单，不解释了} 插入函数（insert） 从这插入函数观察二叉树的构成特点：左子节点小于父节点，右子节点大于父节点（节点不会重复） 这个特点就导致插入的时候有一个特性：以这个特点往下寻找插入点必然是叶节点，从而使插入特别方便。 函数还是递归实现的函数，逐次往下寻找（二叉树的结构导致如果树高了必然会导致搜索耗费大量的时间，之后会有扁平的处理方法） 1234567891011121314151617template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root); //表示从根节点往下寻找插入点}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); //若根节点不存在，则直接存进去 else if (x.key &lt; t-&gt;data.key) //若小于当前节点则向左递归 insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) //大于则向右递归 insert(x, t-&gt;right); //等于的情况直接退出不干，二叉树的插入必须是不同} 查找函数（find） 查找函数就是基于二叉树的结构特点建立的，左小右大 123456789101112131415template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) //如果是不存在或者就是当前的节点 return (SET&lt;KEY,OTHER&gt;*)t; //找到就返回这个指针,没有的话就是返回空指针 if (x &lt; t-&gt;data.key) //如果小于则向左找 return find(x.t-&gt;left); else return find(x, right); //大于则向右找} 注意：有人可能会注意到，t不是BinarNode吗，怎么能强制转换为SET类的指针啊 1return (SET&lt;KEY,OTHER&gt;*)t; 这里需要解释一下结构体和类的一个特点： 对于类和结构的存贮使从第一个数据成员开始的。 举个例子：对于BinarNode的存储空间第一个就是存放的SET，因为在定义里面是写在第一个的。 从而对于指向BinaryNode存储空间的指针某种意义上也是指向了SET的开头，进而可以进行强制转换 12345678910//树节点的结构体struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 删除函数（remove） 主体思路： 删除大体是这个思路为了保证树的结构不变，主要分三种情况 1.如果这个删除节点没有度数为0，很简单删除就好了 2.只有一个子节点，把字节点复制上去，把字节点删除 3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数 其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点） 对于这题我们假设向右子节点寻求最接近的值 最关键的是： 首先，替代问题，为了保证稳定性必须要替换一个最接近的节点互换位置，顶替 其次由于结构最接近无非 最近但小于（左节点的最右节点）和最近但大于 （右节点的最左字节点） 这个寻找方法便捷的地方在于必然是叶子节点替换，也易于删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445//这里的实现主要是最右子节点最左节点（大于且最靠近的树）template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ //先找到要删除的节点 if (t == NULL)return; //第一种情况空节点返回 if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); //第二种情况，要删除小于当前节点，往左递归 else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); //第三种情况要找的大于当前节点，往右边递归 else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //循环找到右子节点的最左节点 t-&gt;data = tmp-&gt;data; //替换俩个节点顺序 remove(t-&gt;data.key, t-&gt;right); //删除替换后的叶子节点，结束 } //第四种，找到了当前节点就是要删除的节点，但是左右都有子节点 else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; //如果有一个子节点，t就是直接替换为子节点，然后删除原来的节点，即使没有子节点，t变为空间点也合乎逻辑 delete oldNode; } //第五种，找到了要么一个子节点，要么没有 //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理} 有一点需要注意： 1&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t) 我们发现节点的参数传递都是引用传递，那是为了方便节点直接替换 例如remove，正是因为引用传递，在层层递归中确保每次传下来的t都是确确实实来自于父节点里面直接的左右节点的指针 这样就维持了上下关系，确保修改是有效的 ##总结：至此就分析结束了 （有时间在这里补一个二叉树查找性能的分析）","link":"/articles/yang/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"}],"tags":[{"name":"游戏心得","slug":"游戏心得","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"奥日与萤火森林体会","slug":"奥日与萤火森林体会","link":"/categories/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%A3%AE%E6%9E%97%E4%BD%93%E4%BC%9A/"},{"name":"yang","slug":"yang","link":"/categories/yang/"}],"pages":[]}