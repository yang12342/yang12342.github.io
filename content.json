{"posts":[{"title":"","text":"类的继承 在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。 那今天就好好看看关于继承方面要注意的语法点 派生类的定义123456789class 派生类名：继承方式 基类名{ 新增加的成员定义；}class student: public people{ }; 唯一要说明的其实就是继承方式 public public（公有类）指的是对应的成员变量和函数可以被外界（全局函数，其他类的成员函数），自己的成员函数和友元直接调用 最直观的就是被外界调用（前提是这些在类内是public） 1234student 小明； 小明.height(); //函数返回 小明。height； //直接返回成员变量//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量 private private（私有类）就是仅仅只限于类内的成员函数和友元进行访问 protected protected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数 但是基类的成员函数和成员变量的访问特性也会随着继承方式变化 基于成员的访问特性 public继承 protected继承 private继承 public public protected private private 不可访问 不可访问 不可访问 protected protected protected private 其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性 我们只需要关注继承过来的变量对于当前类的访问特性。 123456789101112131415161718class base{private: int a;public: void deal();};class base1:protected base{ //这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用 //public继承过来则是protected类，说明可以继续往下继承};class base2:protected base1{ //这个也是完全能调用deal}; 其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用 派生类对象的构造和析构 好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。 因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要 但还是得了解不是吗？ 继承的构造和析构其实也很好理解 对于子类的构造，优先级是这样的 基类的构造函数 自己里面包含的其他类的构造函数 然后是自己的构造函数 派生类的构造函数形式如下 1234student(int a,int b):people(a){ //在：后面给对应的基类传去对应的参数就行} 注意：派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决 析构函数的顺序则是相反 先执行自己的析构函数 再解决基类的析构函数 重定义基类的函数当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖 123456789101112131415161718192021class base{public: int deal(){}}class base1:public base{public: int deal(){}}//此时调用base1.deal则是用派生类定义的deal//如果需要调用父类的那个函数class base{public: int deal() { base:deal(); //需要“基类名：函数名”来调用父类的重定义的函数 }} 将派生类对象隐式转换为基类对象1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员 1base=base1； 2.基类指针指向派生类（很重要） 在植物明星大乱斗中，我们都是通过基类指针指向派生的对象 player指针指向豌豆和向日葵，scene指向不同的场景 基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。 因此指向派生类的基类指针出发，只能访问派生类中的基类成员。 1234567891011121314class base{public: void deal() { }};class base1:public base{ void play();}base* point=new base;point-&gt;deal(); //这是可以的point-&gt;play(); //这是不行的 注意：虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展 但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？ Q&amp;A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量 3.基类对象引用派生类的对象 引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分 1base &amp;point=new base1; 这样对基类引用的访问其实就是对派生类的基类的访问 注意： 派生类的指针不能指向基类 派生类的指针也不能接受基类的指针 123base1 d,*dp;base *bp=dp; //基类指针指向派生类，正确的dp=bp; //但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的 如果强制要转,使用强制类型转换（明确不会犯错） 1dp=reinterpret_cast&lt;Derived*&gt; bp; 最后附上一段植物明星大乱斗子弹类的继承（删了一些）基类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#ifndef _BULLET_H_#define _BULLET_H_#include &quot;vector2.h&quot;#include &quot;player_id.h&quot;#include &quot;camera.h&quot;#include &lt;graphics.h&gt;#include &lt;functional&gt;extern bool is_debug;class Bullet{public: Bullet() = default; ~Bullet() = default; void set_callback(std::function&lt;void()&gt; callback) { this-&gt;callback = callback; } void set_valid(bool flag) { valid = flag; } bool get_valid()const { return valid; } bool check_can_remove()const { return can_remove; } virtual void on_collide() { if (callback) callback(); } virtual bool check_collision(const Vector2&amp; position, const Vector2&amp; size) { return this-&gt;position.x + this-&gt;size.x / 2 &gt;= position.x &amp;&amp; this-&gt;position.x + this-&gt;size.x / 2 &lt;= position.x + size.x &amp;&amp; this-&gt;position.y + this-&gt;size.y / 2 &gt;= position.y &amp;&amp; this-&gt;position.y + this-&gt;size.y / 2 &lt;= position.y + size.y; } virtual void on_update(int delta){} virtual void on_draw(const Camera&amp; camera)const { if (is_debug) { setfillcolor(RGB(255, 255, 255)); setlinecolor(RGB(255, 255, 255)); rectangle((int)position.x, (int)position.y, (int)position.x + size.x, (int)position.y + size.y); solidcircle((int)(position.x + size.x / 2), (int)(position.y + size.y / 2), 5); } }protected: //为了方便子类可以直接读取数据，所以选择protected Vector2 size; //子弹尺寸 Vector2 position; //子弹位置 Vector2 velocity; //子弹速度 int damage = 10; //子弹伤害 bool valid = true; //子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画 bool can_remove = false; //子弹是否可以被移除 std::function&lt;void()&gt; callback; //子弹碰撞回调函数，因为子弹可以积攒玩家的能量 PlayerID target_id = PlayerID::P1; //子弹碰撞目标玩家ID，以免自己打自己protected: bool check_if_exceeds_screen() { return (position.x + size.x &lt;= 0 || position.x &gt;= getwidth() || position.y + size.y &lt;= 0 || position.y &gt;= getheight()); }};#endif // !_BULLET_H_ 派生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#ifndef _PEA_BULLET_H_#define _PEA_BULLET_H_#include &quot;bullet.h&quot;#include &quot;animation.h&quot;extern IMAGE img_pea;extern Atlas atlas_pea_break;class PeaBullet :public Bullet{public: PeaBullet() { size.x = 64; size.y = 64; damage = 10; animation_break.set_atlas(&amp;atlas_pea_break); animation_break.set_interval(100); animation_break.set_loop(false); animation_break.set_callback([&amp;]() {can_remove = true; }); } ~PeaBullet() = default; void on_collide() { Bullet::on_collide(); switch (rand() % 3) { case 0: mciSendString(_T(&quot;play pea_break_1 from 0&quot;), NULL, 0, NULL); break; case 1: mciSendString(_T(&quot;play pea_break_2 from 0&quot;), NULL, 0, NULL); break; case 2: mciSendString(_T(&quot;play pea_break_3 from 0&quot;), NULL, 0, NULL); break; } } void on_update(int delta) { position += velocity * (float)delta; if (!valid) animation_break.on_updata(delta); if (check_if_exceeds_screen()) can_remove = true; } void on_draw(const Camera&amp; camera)const { if (valid) putimage_alpha(camera, (int)position.x, (int)position.y, &amp;img_pea); else animation_break.on_draw(camera, (int)position.x, (int)position.y); Bullet::on_draw(camera); }private: Animation animation_break; };#endif // !_PEA_BULLET_H_","link":"/2024/06/21/C++%E7%BB%A7%E6%89%BF/"},{"title":"","text":"AVL树解析（基于查找二叉树（dynamicSearchTree））平衡二叉树：在查找二叉树的基础上要求每个节点左右字节点的高度差不能超过一。 于是对于节点多了一个数据成员高度来实现这一功能。 先附上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;dynamicSearchTable.h&quot;template &lt;class KEY, class OTHER&gt;struct SET{ KEY key; //关键字信息 OTHER other; //和其他信息};template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x);private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); bool remove(const KEY&amp; x, AvlNode*&amp; t); void makeEmpty(AvlNode* t); int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} void LL(AvlNode*&amp; t); void LR(AvlNode*&amp; t); void RL(AvlNode*&amp; t); void RR(AvlNode*&amp; t); int max(int a, int b) { return (a &gt; b) ? a : b;} bool adjust(AvlNode*&amp; t, int subTree);};template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) { if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; else return (SET&lt;KEY, OTHER&gt;*)t; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;left; t-&gt;left = t1-&gt;right; t1-&gt;right = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; }template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) { AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); LL(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) { insert(x, t-&gt;left); if (height(t-&gt;left) - height(t-&gt;right) == 2) if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); else LR(t); } else if (t-&gt;data.key &lt; x.key) { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1;}template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; if (x == t-&gt;data.key) { if (t-&gt;left == NULL || t-&gt;right == NULL) { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; return false; } else { AvlNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; if (remove(tmp-&gt;data.key, t-&gt;right))return true; return adjust(t, 1); } } if (x &lt; t-&gt;data.key) { if (remove(x, x-&gt;left))return true; return adjust(t, 0); } else { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } RR(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; }}template&lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::makeEmpty(AvlNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;} 基本组成成员 AvlNode（AVL的树节点） 12345678910struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; //节点的高度 AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h=1):data(element),left(lt),right(rt),height(h){} }; 多了一个高度，构造函数默认为1（指只有自己） 根节点 1AvNodee* root; AVL类的基本数据成员和函数12345678910111213141516171819202122232425262728293031template &lt;class KEY,class OTHER&gt;class AvlTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{ struct AvlNode { SET&lt;KEY, OTHER&gt;data; AvlNode* left; AvlNode* right; int height; AvlNode(const SET&lt;KEY, OTHER&gt;&amp; element, AvlNode* lt, AvlNode* rt, int h = 1):data(element),left(lt),right(rt),height(h){} }; AvNodee* root;public: AvlTree() { root = NULL;} ~AvlTree() { makeEmpty(root);} SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数 void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有） void remove(const KEY&amp; x); //删除函数（公有）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, AvlNode*&amp; t); //插入函数（私有） bool remove(const KEY&amp; x, AvlNode*&amp; t); //删除函数（私有） void makeEmpty(AvlNode* t); //清空 int height(AvlNode* t)const { return t == NULL ? 0 : t-&gt;height;} //计算当前节点的高度 void LL(AvlNode*&amp; t); //单旋转LL void LR(AvlNode*&amp; t); //双旋转LR void RL(AvlNode*&amp; t); //双旋转RL void RR(AvlNode*&amp; t); //单旋转RR int max(int a, int b) { return (a &gt; b) ? a : b;} //比较函数 bool adjust(AvlNode*&amp; t, int subTree); //调整节点的结构使其平衡的函数}; 其实private类的函数都是公有类函数的工具函数 函数的实现分析 查找函数（find） 123456789101112template &lt;class KEY, class OTHER&gt;SET&lt;KEY, OTHER&gt;* AvlTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ AvlNode* t = root; while (t != NULL &amp;&amp; t-&gt;data.key != x) //循环停止的条件，就是当前节点为空或者就是要找的 { //小于就换成左节点，反之换成右节点， if (t-&gt;data.key &gt; x)t = t-&gt;left; else t = t-&gt;right; } if (t == NULL)return NULL; //空就返回 else return (SET&lt;KEY, OTHER&gt;*)t; //这里还是强制转换} 还是基于二叉查找树的特性，只是没有使用递归函数，这种方式被称为迭代实现 插入函数（insert） 在介绍函数之前理解一些东西，关于插入的一些特性： 1. 首先插入还是和二叉查找树一样插入在叶子节点上 2. 一次插入后，只有在插入点到根的路径上的节点才有可能发生平衡度的变化 3. AVL的平衡策略最多只要调整一个节点就可以了 主要分析LL和LR俩种情况注意： 对于旋转策略的核心是保证节点的高度不发生变化，就是通过旋转变为原来的高度，从而保证对上面节点安全的保证。 一旦改变了数的高度，那需要不断往上检索，直到那个节点的高度没有发生变化 LL：原来A的左子树比右子树高，插入发生在A的左儿子的左子树中，使A的左子树增高 (注意（仅仅对于插入而言，对于删除这个结论反而相反）：平衡度只是一种高度是否平衡的表现形式，真正影响的是节点的高度，主要体现在平衡度向零趋近高度不变，而向俩边增长表明节点高度发生改变) 此图有图 节点平衡度从-1到0但是并不影响上面的节点，因为这个节点的高度并未发生改变，反而0到1表明当前节点的高度发生改变 现在来分析LL的情况此处有图 首先分析一下一些情况： 1. **首先B的平衡度一定原来是0，然后变为1， 因为我们上面解释过如果是-1到0表明是向零趋近，B的高度不会发生变化，进而不会影响A 若是原来是1，变成2，显然B才是危机节点，处理就不是A了 对于LL解决办法就是向右旋转 此处有图 显然我们发现在旋转后我们发现我们处理的这个树的高度与插入前的高度完全一样，于是不用担心上面节点的平衡度了 思考： 对于这种旋转必然是左右子树未实现满二叉树或者完全二叉树导致，就是有空缺的位置来保证旋转后高度不发生变化 那么假设是满二叉树插入，我们会发现并不影响平衡度都从（0到1或者0到-1） （其实这就是插入点后的检索过程，虽然高度发生了变化，但是一直向上检索发现平衡度没有打破规则，那么就会检索到根节点结束） 现在附上LL代码图 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LL(AvlNode*&amp; t) //注意这里传的是原来的指针，估计是父节点的指针，不然改了没意义 A{ AvlNode* t1 = t-&gt;left; //失衡的A，先标记B点为t1（A的左子节点） t-&gt;left = t1-&gt;right; //B的右子树，变成A的左子树 t1-&gt;right = t; //B的右子节点变成A t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //此时更新各自的高度（+1是为了包括本身） t1-&gt;height = max(height(t-&gt;left), height(t)) + 1; t = t1; //将t彻底变为B点（B成为t的指向点）} 有心情的话 可以在这个补一个过程图，看我以后记不记的住吧 *1.*我们发现指针还是引用传递，主要是我要旋转A点，那么就需要修改A的父节点对应的指针从。原理和二叉查找树的原理相同 RR也是同理只是向左旋转附上RR的代码 12345678910template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RR(AvlNode*&amp; t) //这个和上面是一个道理，就是向左转，就像镜像一样{ AvlNode* t1 = t-&gt;right; t-&gt;right = t1-&gt;left; t1-&gt;left = t; t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; t1-&gt;height = max(height(t-&gt;right), height(t)) + 1; t = t1;} 现在来分析LR的情况为什么要单独讨论这种情况？因为我们发现仅仅如果使用LL右旋发现只是不过对这个树镜像对称过去了而已，A点仍然是失衡点，只不过是现在是右子树高了 此处有图 我们相对于之前多了一个参考C节点，对于CL和CR谁的高度为h-1并不重要 为了保证根节点的高度不发生变化，我们选择LR的双旋转的方法，对B点进行左旋转（RR），再对A点进行右旋转（LL） 不难发现，C点占据了原来的根节点，且平衡度恢复了0，因为是1到0我们便可认定节点的高度没有发生变化，从而无需再向上检索 过程如下图显示 其实逻辑也很好理解就是让根节点的右边多一个高度来平衡多的那个节点 代码如下 123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::LR(AvlNode*&amp; t) { RR(t-&gt;left); //先对B进行左旋 LL(t); //再对A点进行右旋} RL也完全是同理，就是对称了一下123456template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::RL(AvlNode*&amp; t){ LL(t-&gt;right); RR(t);} 以上我们分析了四种旋转情况接下来就来分析插入函数前面我们提到了一个关键词回溯 对于代码里面的回溯就是在修改后往回检查，最好想的就是树了，我修改了叶节点，我需要对查找路径上的每一个点进行检查，那么我们在代码中如何往回实现这个功能呢？ 答案就是利用 递归 假如我们要进行修改，并检查，可以用如下伪代码实现 12345678910插入函数{检查当前节点是不是插入点，是就插入不是就根据于当前节点的大小调用“函数（左节点）/函数（右节点）”//因为是递归调用，执行到这一样表示递归所有的修改已完成开始回溯了检查当前节点的平衡度来看是否需要调整，若失衡分类讨论重新计算高度} 附上代码 其实我们发现这个回溯必须全部走完，因为要更改高度（尤其是满二叉树那种虽然不影响平衡度，但是路径上所有节点高度都需要+1） 1234567891011121314151617181920212223242526272829303132template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template &lt;class KEY, class OTHER&gt;void AvlTree&lt;KEY,OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp;x, AvlNode*&amp; t){ if (t == NULL) //情况1：如果根节点为空就直接放置 t = new AvlNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) //情况2：如果比当前节点小，往左子树插入 { insert(x, t-&gt;left); //向下递归 if (height(t-&gt;left) - height(t-&gt;right) == 2) //执行到这一步表示左子树全部节点都平衡了，检查自己了 if (x.key &lt; t-&gt;left-&gt;data.key)LL(t); //当前节点失衡了，只要判断插入节点是在左子节点的左右 //就可以判断是哪种情况 else LR(t); } else if (t-&gt;data.key &lt; x.key) //这里的逻辑是一样的，参照上面就行了 { insert(x, t-&gt;right); if (height(t-&gt;right) - height(t-&gt;left) == 2) if (t-&gt;right-&gt;data.key &lt; x.key)RR(t); else LR(t); } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; //在最后插入好，会从底往上重新计算树的高度} 删除函数（remove） 删除节点很有可能导致树变矮，导致二叉树失衡，所以必须要在删除后不断回溯调整平衡 首先这是一个回溯的过程，还有一个关键点就是是否需要再网上回溯的关键是: 的当前节点的高度在调整后或者未调整高度是否发生变换，注意我说的是高度不是平衡度，若往回检索发现有节点高度未发生变化就可以停止检查调整步骤直接return。 这也表明了虽然删除是递归，但是返回值是一个bool表示当前节点高度是否发生变化从而决定上面的节点是否需要检查 删除过程这一个和二叉查找树没什么区别其实，依旧是分为三种情况（无儿子，一个儿子，俩个儿子） 前俩个可以用一个表达式来代替 1t=（t-&gt;left!=NULL）:t-&gt;left?t-right; 相对后面的情况显示是迭代找到可替换的叶子节点，然后删除叶子节点啦。 检查过程删除的时候没有插入那么幸运，删除时的调整很有可能导致整棵树高度下降，从而影响路上的所有父节点。 停止条件：只有当某个节点读的高度在删除后不变才无需向上检查调整了 导致树的高度发生变化有以下几种情况 （注意：这里平衡度是在向两边增长节点高度不变，向零靠近节点高度发生变化，因为是删除 （与插入的结论恰恰相反，插入是有可能增高，而删除是有可能降低高度）） 此处有五种情况（假设都是在左子树上删除的节点） 此处有图 对于（a）的平衡度既没有失衡，高度也没有发生变化 对于（b）平衡度没有失衡，但是根据平衡度的变化可以发现节点的高度发生变换，需要检查父节点 对于（c）只需要节点P使用左旋（RR）即可，这样根节点的高度就变成了0，虽然平衡了但是平衡度从-1变为0，节点高度发生变化，需要检查父节点 对于（d）显然左旋仍然导致失衡，就像前面的RL的情况一样发生在内侧，这个时候就需要先对P的右子节点先右旋（LL）再对P进行左旋（RR），就会使根节点平衡度变为0.不需要对父节点进行检查 对于（e）对P使用简单的左旋（RR）根节点（原来P的位置）的平衡度变为1（注意平衡度从-1到1，节点的高度并未发生变化，可以认为就像交换了一样）；当然可以使用RL，这样的话根节点的平衡度仍为-1，高度未发生变化。所以俩种方法都不需要检查父节点 对于添加在右子节点的方法对称就好了 附上代码 （指针参数还是引用，原因上面解释过了） （true表示不用检查，false表示节点的高度发生变化，需要检查节点的高度） 删除函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class KEY,class OTHER&gt;void AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, AvlNode* &amp; t){ if (t == NULL)return true; //空树不存在，不用检查父节点 if (x == t-&gt;data.key) //情况1：如果是当前节点 { if (t-&gt;left == NULL || t-&gt;right == NULL) //删除情况1，2：如果只是有一个子节点或者没有节点 { AvlNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; //因为对只有一个节点或者无叶节点的删除必然导致高度变换，肯定是 return false; //要检查的 } else { AvlNode* tmp = t-&gt;right; //删除情况三：有俩个子节点 while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //迭代找到右子树的最左子节点 t-&gt;data = tmp-&gt;data; //数据替换 if (remove(tmp-&gt;data.key, t-&gt;right)) //然后就是删除的目标换成最新的叶节点，从当前的节点右节点开始 return true; //如果这个删除最后返回的是true，表明右子节点的高度未变化 return adjust(t, 1); //1表示删除在右子树上，t表示当前节点失衡，需要调整 } } if (x &lt; t-&gt;data.key) //情况2：小于则是向左找 { if (remove(x, x-&gt;left))return true; //向左递归 return adjust(t, 0); //如果需要检查，则调用adjust，0表示删除的是左子树 } else //情况三：大于则是向右找 { if (remove(x, t-&gt;right))return true; return adjust(t, 1); }} 这段逻辑其实挺绕人的，remove函数的返回值主要三种： 1：删除的是只有一个字节点或者无子节点（直接返回true，必然改变高度） 2：向下递归调用remove，如果调用返回的是true，则自己不用调整，也返回true 3：如果调用的remove返回false，则需要返回adjust，一边检查高度是否发生变换+调整，调整后如果高度变化返回false，反之true（具体就是我们讨论的几个调整情况） 调整函数（adjust） 参数subTree（subtract Tree）1表示删除的右子树，0表示删除的左子树 0则是我们讨论的那五种情况 1则是完全对称的五种情况 调用adjust不一定高度有变化，但是平衡度一点是发生变化了 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class KEY, class OTHER&gt;bool AvlTree&lt;KEY, OTHER&gt;::adjust(AvlNode*&amp; t, int subTree) { if (subTree) //如果删除的是右子树，逻辑和下面的只是镜面对称 { if (height(t-&gt;left) - height(t-&gt;right) == 1)return true; if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } if (height(t-&gt;left-&gt;right) &gt; height(t-&gt;left-&gt;left)) { LR(t); return false; } LL(t) if (height(t-&gt;right) == height(t-&gt;left))return false; else return true; } else //如果删除的是左子树 { if (height(t-&gt;right) - height(t-&gt;left) == 1)return true; //对应（a）删除的左子树，如果是当前平衡度为-1，表示之前的平衡度就是0（如果是-1的话根本不会调用adjust好吧），因为删除是左子树，只有左子树降低高度的可能，（表示根据前面由平衡度判断高度结论判定）当前节点不需要调整+高度也没有发生变化 if (height(t-&gt;right) == height(t-&gt;left)) { --t-&gt;height; return false; } //对应情况（b），根据结论一定是从1到0，高度一定发生变化了，但是平衡度依旧正常，返回false if (height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right)) { RL(t); return false; } //对应情况（d），右子节点的左子树的节点的高度大于右子树进行RL RR(t) if (height(t-&gt;right) == height(t-&gt;left)) return false; else return true; //对于（c）和（e）只需要RR（左旋即可），对于这两种情况使用RR后的区别就是（c）调整后平衡度为0，节点高度发生变化return false，对于（e）使用RR，节点应该变为1，但是高度没有发生变化，return true }} 到此难的地方已经处理好了其他的构造析构都是完全继承完全二叉树，所以不再赘述了 有时间再补补性能分析吧","link":"/2024/06/09/AVL/"},{"title":"","text":"二叉查找树 先附上完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133template &lt;class KEY,class OTHER&gt;struct SET{ KEY key; OTHER other; };template&lt;class KEY,class OTHER&gt;class dynamicSearchTable{public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; virtual void remove(const KEY&amp; x) = 0; virtual ~dynamicSearchTable() {};};template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; public: BinarySearchTree(); ~BinarySearchTree(); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; void insert(const SET&lt;KEY, OTHER&gt;&amp; x); void remove(const KEY&amp; x); private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); void remove(const KEY&amp; x, BinaryNode*&amp; t); SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; void makeEmpty(BinaryNode* t);};template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) return (SET&lt;KEY,OTHER&gt;*)t; if (x &lt; t-&gt;data.key) return find(x.t-&gt;left); else return find(x, right); }template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); else if (x.key &lt; t-&gt;data.key) insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) insert(x, t-&gt;right);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ if (t == NULL)return; if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; t-&gt;data = tmp-&gt;data; remove(t-&gt;data.key, t-&gt;right); } else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; delete oldNode; }}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL;}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; makeEmpty(t-&gt;left); makeEmpty(t-&gt;right); delete t;}template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root);}int main(){ return 0;} 前提组成 template &lt;class KEY,class OTHER&gt; struct SET { KEY key; //关键字信息 OTHER other; //和其他信息 }; 123456789101112131415 这是基本的数据元素 分别包括**键值**key和**其他值**value（就像字典里面对应的查找关键和词语解释）- ~~~c++ template&lt;class KEY,class OTHER&gt; class dynamicSearchTable { public: virtual SET&lt;KEY, OTHER&gt;* find(const KEY&amp; x) = 0; //查找目标元素，返回值为指针 virtual void insert(const SET&lt;KEY, OTHER&gt;&amp; x) = 0; //插入功能 virtual void remove(const KEY&amp; x) = 0; //显然是删除功能 virtual ~dynamicSearchTable() {}; //析构函数 }; 这就是二叉查找树的父类**动态查找表**，也可以看作一个模板而已，提供了基础的一个动态查找的基本功能模板 动态二叉树 动态二叉树的主体类函数 1234567891011121314151617181920212223242526template&lt;class KEY, class OTHER&gt;class BinarySearchTree :public dynamicSearchTable&lt;KEY, OTHER&gt;{private: struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root;public: BinarySearchTree(); //构造函数 ~BinarySearchTree(); //析构函数 SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x)const; //查找函数（公有，面向使用者） void insert(const SET&lt;KEY, OTHER&gt;&amp; x); //插入函数（公有，面向使用者） void remove(const KEY&amp; x); //删除函数（公有，面向使用者）private: void insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t); //查找函数（私有，面向公有调用函数） void remove(const KEY&amp; x, BinaryNode*&amp; t); //插入函数（公有，面向公有调用函数） SET &lt;KEY, OTHER&gt;* find(const KEY&amp; x,BinaryNode* t)const; //删除函数（公有，面向公有调用函数） void makeEmpty(BinaryNode* t); //清空函数}; 树的节点分析： 123456789struct BinaryNode { SET&lt;KEY, OTHER&gt;data; //本体的数据 BinaryNode* left; //左子节点的指针 BinaryNode* right; //右子节点的指针 BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, //节点的构造函数，可以直接设定三个成员 BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 注意：后面经常会用到公有函数调用私有函数，虽然名称一样，但一个面向使用者，私有的面向共有的函数调用内部 12345void remove(const KEY&amp; x) //删除函数（公有，面向使用者）{ remove(x,root); //这里调用的就是私有函数}void remove(const KEY&amp; x, BinaryNode*&amp; t); //这就是私有函数的接口和实现 接下来分析函数的实现 构造函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::BinarySearchTree(){ root = NULL; //简单初始化了一下根节点} makempty 主要还是递归循环删除，采用了前序遍历的思想 12345678template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t){ if (t == NULL)return; //递归终止的条件（删到了空节点） makeEmpty(t-&gt;left); //正常步骤先删左节点，往下递归 makeEmpty(t-&gt;right); //再删右节点，往下递归 delete t; //删除自己 }//最后就删除了所给节点和节点的所有子节点 拓展：其实最近刷题还看到了一种实现方法就是入队和出队在这里 优点：就是摆脱了递归的对于空间的大量调用，利用循环和队列实现（更多是在链表使用的方法） 其实这是层序遍历的使用方法，只是用这个实现了层序遍历的删除方式 123456789101112131415&gt;**自己拓展的，不是范例的**&gt;Queue&lt;BinaryNode*&gt; queue; //存放节点指针的队列&gt;template&lt;class KEY, class OTHER&gt;&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::makeEmpty(BinaryNode* t)&gt;{queue.enqueue(t); //先把根节点放入队列 while(t.isempty()) //终止条件：检查队列是否为空，不空则继续进行 { BinaryNode* t=queue.dequeue(); //出队队列的第一个节点 if(t-&gt;left!=nullptr)queue.enqueue(t-&gt;left); //左子节点有就放进队列，没则不处理 if(t-&gt;right!=nullptr)queue.enqueue(t-&gt;right); //同理 delete t; //然后删除自己 }&gt;} 析构函数 12345template&lt;class KEY, class OTHER&gt;BinarySearchTree&lt;KEY, OTHER&gt;::~BinarySearchTree(){ makeEmpty(root); //就从root开始删除，很简单，不解释了} 插入函数（insert） 从这插入函数观察二叉树的构成特点：左子节点小于父节点，右子节点大于父节点（节点不会重复） 这个特点就导致插入的时候有一个特性：以这个特点往下寻找插入点必然是叶节点，从而使插入特别方便。 函数还是递归实现的函数，逐次往下寻找（二叉树的结构导致如果树高了必然会导致搜索耗费大量的时间，之后会有扁平的处理方法） 1234567891011121314151617template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x){ insert(x, root); //表示从根节点往下寻找插入点}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::insert(const SET&lt;KEY, OTHER&gt;&amp; x, BinaryNode*&amp; t){ if (t == NULL) t = new BinaryNode(x, NULL, NULL); //若根节点不存在，则直接存进去 else if (x.key &lt; t-&gt;data.key) //若小于当前节点则向左递归 insert(x, t-&gt;left); else if (t-&gt;data.key &lt; x.key) //大于则向右递归 insert(x, t-&gt;right); //等于的情况直接退出不干，二叉树的插入必须是不同} 查找函数（find） 查找函数就是基于二叉树的结构特点建立的，左小右大 123456789101112131415template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x)const{ return find(x, root);}template&lt;class KEY, class OTHER&gt;SET &lt;KEY, OTHER&gt;* BinarySearchTree&lt;KEY, OTHER&gt;::find(const KEY&amp; x, BinaryNode* t)const{ if (t == NULL || (t-&gt;data.key == x)) //如果是不存在或者就是当前的节点 return (SET&lt;KEY,OTHER&gt;*)t; //找到就返回这个指针,没有的话就是返回空指针 if (x &lt; t-&gt;data.key) //如果小于则向左找 return find(x.t-&gt;left); else return find(x, right); //大于则向右找} 注意：有人可能会注意到，t不是BinarNode吗，怎么能强制转换为SET类的指针啊 1return (SET&lt;KEY,OTHER&gt;*)t; 这里需要解释一下结构体和类的一个特点： 对于类和结构的存贮使从第一个数据成员开始的。 举个例子：对于BinarNode的存储空间第一个就是存放的SET，因为在定义里面是写在第一个的。 从而对于指向BinaryNode存储空间的指针某种意义上也是指向了SET的开头，进而可以进行强制转换 12345678910//树节点的结构体struct BinaryNode { SET&lt;KEY, OTHER&gt;data; BinaryNode* left; BinaryNode* right; BinaryNode(const SET&lt;KEY, OTHER&gt;&amp; thedata, BinaryNode* It = NULL, BinaryNode* rt = NULL):data(thedata),right(rt){} }; BinaryNode* root; 删除函数（remove） 主体思路： 删除大体是这个思路为了保证树的结构不变，主要分三种情况 1.如果这个删除节点没有度数为0，很简单删除就好了 2.只有一个子节点，把字节点复制上去，把字节点删除 3.这个最复杂，因为他又俩个节点，为了保证树结构不变必然是在叶子节点中找到最靠近这个节点的数 其实根据这个查找二叉树的结构，分析出最接近的是左子节点一直往子节点的右子节点找（左子节点&lt;x&lt;当前节点），或者是右子节点的左子节点一直找（当前节点&lt;x&lt;右子节点） 对于这题我们假设向右子节点寻求最接近的值 最关键的是： 首先，替代问题，为了保证稳定性必须要替换一个最接近的节点互换位置，顶替 其次由于结构最接近无非 最近但小于（左节点的最右节点）和最近但大于 （右节点的最左字节点） 这个寻找方法便捷的地方在于必然是叶子节点替换，也易于删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445//这里的实现主要是最右子节点最左节点（大于且最靠近的树）template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x){ remove(x, root);}template&lt;class KEY, class OTHER&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t){ //先找到要删除的节点 if (t == NULL)return; //第一种情况空节点返回 if (x &lt; t-&gt;data.key)remove(x, t-&gt;left); //第二种情况，要删除小于当前节点，往左递归 else if (t-&gt;data.key &lt; x)remove(x, t-&gt;right); //第三种情况要找的大于当前节点，往右边递归 else if (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL) { BinaryNode* tmp = t-&gt;right; while (tmp-&gt;left != NULL)tmp = tmp-&gt;left; //循环找到右子节点的最左节点 t-&gt;data = tmp-&gt;data; //替换俩个节点顺序 remove(t-&gt;data.key, t-&gt;right); //删除替换后的叶子节点，结束 } //第四种，找到了当前节点就是要删除的节点，但是左右都有子节点 else { BinaryNode* oldNode = t; t = (t-&gt;left != NULL) ? t-&gt;left : t-&gt;right; //如果有一个子节点，t就是直接替换为子节点，然后删除原来的节点，即使没有子节点，t变为空间点也合乎逻辑 delete oldNode; } //第五种，找到了要么一个子节点，要么没有 //有没有发现，我选择右子树寻找替代，那么替代的那个点也是右子树要处理} 有一点需要注意： 1&gt;void BinarySearchTree&lt;KEY, OTHER&gt;::remove(const KEY&amp; x, BinaryNode*&amp; t) 我们发现节点的参数传递都是引用传递，那是为了方便节点直接替换 例如remove，正是因为引用传递，在层层递归中确保每次传下来的t都是确确实实来自于父节点里面直接的左右节点的指针 这样就维持了上下关系，确保修改是有效的 ##总结：至此就分析结束了 （有时间在这里补一个二叉树查找性能的分析）","link":"/2024/06/08/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8dynamicSearchTree%EF%BC%89/"},{"title":"奥日与萤火森林2","text":"玩奥日有感（真随笔）剧情上 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图解锁了地底下和森林的碎片唤醒了底下的蜘蛛（被腐朽吞噬了心智）夸洛克牺牲了自我换回碎片 剧情就不得不提到npc了莫基——路人角色，大大小小的任务都有承担，森林的原住民算是库克——地图提供者猴子——推动剧情，教会武器方面技能商人——交易升级技能夸洛克——沼泽的庇护神工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器 玩法上在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。在角色系统我会介绍这些对玩法的贡献 主要是——场景，场景关卡设置，物品和玩法剖析 场景的关卡前期的最大关卡就是【1】找到散落的楔石打开石门小的关卡【2】拖拽石头来阻挡机关和帮助跳跃还有类似司机挡位的机关——触发一些机关，打开石门等等【3】还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏 场景物品藤条——帮助跳跃竖直木棒——陷阱悬停水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了羽毛——还有库和奥日的配合玩法—— 补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯 玩法其实有的已经融合在以上或者以下的分析里面主要探索，打斗剧情的玩法——对话打斗boss等boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣 场景第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景 从角色系统上分析主要分为四个部分 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条） 武器+主动技能系统从光剑到弓箭到重锤，技能则有光之箭和回血等评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。光剑——可以打碎一些木板障碍物例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速重锤——可以打碎石板光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）其他目前武器目前没有看到对地图探索的作用，有再补充 不可见的被动技能例如二连跳抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深 课拆卸购买升级的被动技能首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级技能框则是探索地图一步一步的去扩展讲几个印象比较深的技能:攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行三连跳——好吧也是默认了，不仅帅而且探索地图确实方便其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧 （4）","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%A3%AE%E6%9E%97%E4%BD%93%E4%BC%9A/"},{"title":"欢迎来到我的博客，见证我的成长","text":"在此特别感谢voidMatrix老师和从零开始的C++游戏开发的群友的帮忙！！ 希望群友们能够在今后的日子里互相帮助互相进步，也祝V老师事业蒸蒸日上！！","link":"/2024/06/03/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%A7%81%E8%AF%81%E6%88%91%E7%9A%84%E6%88%90%E9%95%BF/"},{"title":"笼中窥梦","text":"笼中窥梦心得第一次玩到这个游戏我就想到了初中玩的画中世界，视觉错觉的艺术美与打动人心且朦胧的故事感，很平静却又是如此吸引人。感觉就像是在品味人生，同时享受着美妙的艺术。 从叙事性上看吧，这类的游戏没有明确表述主线，都是以一种很朦胧大概的方式，只言片语的描绘故事，这就像一千个读者一千个哈姆雷特，我觉得这种叙事方式却给了玩家最好的体验。叙事主要是从游戏的场景，拾起的相片，和游戏交互推动的。从我第一次简单通关的角度描绘我眼中的故事：大体上是简单的讲述了一个人的一生，从小然后成长为一位研制武器的科学家，颇有成果但是在战乱后他同样参军，流离失所，于硝烟中漂泊，见识到了他的武器在战争中给无数人带来的苦难，一路走来，他见证了多少美好的过去被战火所毁灭，春去秋来，撑到了战争结束的一天，但是他却孑然一身，陷入了深深的自责与内疚，他走不出这段阴影，更对不起过去小时候的自己，看到无数因为战争而生出的坟墓，时常到教堂去忏悔自己罪恶（这个教堂是当时的一个场景，经理三个阶段，战争前，被毁灭，被重建，也许也暗示主线的过程）。但是在一步步中他慢慢打开了心结，离开了医院，回到了过去的小屋接纳当下的自己。最让我印象深刻的场景就是最后，过去小时候的照片中的自己与今天的自己被拼接在一起，俩个人面面相觑，但最后成长的自己将小时候的自己紧紧抱入了怀中，说真的那个时候真的很感人。最后的最后，场景再次回到了游戏开始的时候。怎么说呢，笼中窥梦，确实在一个一个个镜面里窥看一个人的一生，也许是梦，也许是一个人的故事，而且视觉错位的艺术玩法和诗意平静的叙事方式真的很打动人吧，最后回到故事的开始，是梦醒，更让我感受到这个游戏就像梦一样。人的一生坎坎坷坷，跌跌撞撞，最美好的故事的结局还是走到故事的起点吗？ 游戏的场景上，每一个场景都蕴含了主角故事的较为关键的节点，同时一些场景也在隐喻着一些事情，举个例子其中一个场景是启动导弹的发射，于是故事的叙事开始从战争的角度开始描述，还有前面的教堂的变换贯穿了战争和战后，从长满杂草到被战火摧残再到重建成为人们心里的寄托，也许反应主人公的心境吧。 在玩法上，确实很有创新，利用场景的拼接去描述一个一个故事。难度上不是很大，高亮是当下要用的，浅亮的重要但是不是当下用，而且可以选择提示和演示视频（我中间确实有几次卡关了），一方面是可利用的游戏场景他不会标记，你可能想不到，另一方面有的交互是一连串触发有时间的限制，影响最深的就是一个炮弹滚了大概三四个场景才完成最终的目的，但整体看下来不是很难，有些地方有小彩蛋来解锁成就。虽难脑袋不是很适合解密，但是视觉错觉的艺术玩法和平静诗意的叙事很触动我，也许是生活缺少了感动（我承认我情商确实低…….）在音乐上，额，几乎没有背景音乐，只有互动场景的音效，我觉得是不是可以配上一点适合氛围的音乐（虽然只有俩个人做出来确实不容易），但是当下这个作品已经近乎完美了。 漫谈 ：提到游戏，我更加喜欢像这样叙事朦胧却又真的打动人心，仅仅通过场景去体会这种故事。我玩的游戏不多，但是像这样印象深刻就是画中世界和地狱边境。画中世界的故事梗概记不住了，美术相当出色，解密做的也很好，地狱边境的内容比较清楚，好像是描述一家人遭遇了车祸，然后弟弟在地狱只有黑白的场景一路寻找他的姐姐，相较于这个游戏那个故事更有起伏，因为有怪物的存在，但是最后他终于姐姐相会了（也许是俩个人最后都离开了），同样有姐姐的我当时也是印象深刻，生离死别，却又在最后看见了你最后一眼，真的是。。。。 最后说一说笼中窥梦的作者，感兴趣的可以上b站搜《钱从哪来》的栏目，有一期就采访了他们的团队，俩个人，一个程序策划，一个美术，打磨出了这个作品。独立游戏制作的不易，可以从这个节目看到。有一期还是采访了我们学校的一个团队，放弃读研，放弃offer，几个人出来做游戏，可是才发现做独立游戏的道路上确实更多窘境和不易——《成土市的我》《什么鸟都》 看到一个朋友圈是“珍惜身边做独游的人吧，非要说的话那就是爱。” 最后用笼中窥梦的作者的话，“祝愿你做一个好梦”","link":"/articles/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/%E7%AC%BC%E4%B8%AD%E7%AA%A5%E6%A2%A6%E5%BF%83%E5%BE%97/"},{"title":"","text":"计时器[TOC] 游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。 计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。 我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#ifndef _TIMER_H_#define _TIMER_H_#include &lt;functional&gt;class Timer{public: Timer() = default; ~Timer() = default; void restart() { pass_time = 0; shotted = false; } void set_wait_time(int val) { wait_time = val; } void set_one_shot(bool flag) { one_shot = flag; } void set_callback(std::function&lt;void()&gt; callback) { this-&gt;callback = callback; } void pause() { paused = true; } void resume() { paused = false; } void on_update(int delta) { if (paused) return; pass_time += delta; if (pass_time &gt;= wait_time) { if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) callback(); shotted = true; pass_time = pass_time-wait_time; } }private: int pass_time = 0; int wait_time = 0; bool paused = false; bool shotted = false; bool one_shot = false; std::function&lt;void()&gt; callback; }; #endif // !_TIMER_H_ 我们先从函数设置上分析功能 重置计时器（restart） 是否选择重复触发（set_one_shot） 设置重复触发的间隔时间（set_wait_time） 回调函数的设置(set_callback) 计时器暂停(pause) 计时器继续(resume) 计时器数据更新(on_update) 从以上我们就简单看出了计时器的基本功能 状态的转换（单触发还是多次触发） 计时的暂停和继续 每次累计时间到达后执行的回调函数 回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作 类似lambda函数，后面分析函数会具体说明 函数实现的简单分析成员变量1234567private: int pass_time = 0; //单次累计时间 int wait_time = 0; //间隔时间 bool paused = false; //计时器是否暂停 bool shotted = false; //是否触发的状态量 bool one_shot = false; //是否单次触发，false为循环触发 std::function&lt;void()&gt; callback; //回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还 之后还会用到LAMBDA函数，来作为实参传输 restart（）12345void restart() { pass_time = 0; //累计时间清零 shotted = false; //触发状态量回归未触发状态 } 每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据 set_on_shot()1234void set_one_shot(bool flag) //是否单次触发 { one_shot = flag; //false为循环触发 } 有的游戏应用场景下只需要计时器触发一次 例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次） set_wait_time（）1234void set_wait_time(int val) //设置触发的时间间隔 { wait_time = val; } 循环计时需要设置间隔时间 例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔 set_callback()1234void set_callback(std::function&lt;void()&gt; callback) //这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 { this-&gt;callback = callback; } 传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针） 例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex=false;的逻辑 后面分析游戏实例会讲解 pause()&amp;&amp;resume()123456789void pause() { paused = true;}void resume() { paused = false; } 计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值 on_update()1234567891011121314void on_update(int delta) { if (paused) //先检查计时器是否处于暂停状态 return; pass_time += delta; //若不暂停，则计时 if (pass_time &gt;= wait_time) //如果到达了触发间隔且未暂停 { if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) //前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数 callback(); shotted = true; pass_time = pass_time-wait_time; } } 计时器数据更新的关键就是 何时触发和什么条件触发回调函数 （由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键） 12if ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback) callback(); 首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0） 其次就是循环触发（那就不考虑shotted状态了，时间到了就触发）和单次触发且还处于未触发状态（shotted为false） 不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数 关于回调函数和函数指针，lambda函数的分析函数指针 指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针 定义格式：返回类型 （*指针变量）(形式参数表) 12int (*point)(); //指向一个参数，返回值为int的函数int (*point)(int); //指向一个有int参数，返回值为int的函数 注意：声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高 指针的赋值可以是：指针变量名=函数名 1point=f1； 函数指针主要有俩个用途：作为函数的参数（就是作为形参），和实现菜单 作为函数的参数 123456template&lt;class T&gt;void sort(T a[],int size,bool(*f)(T,T)){ //冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较 bool is_bigger=f(a,b)；} 为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入 菜单的实现（其实是函数指针数组的使用） 12345678int main(){ //假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数 void (*menu[6])()={NULL,add,erase,modify,printSalary,printReport}; int n; cin&gt;&gt;n; menu[n];} 就是理解函数指针也是有数组的，让函数的接口变得更见简答易用 lambda函数 看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量 表达形式：**[捕获列表] （形式参数表）-&gt;返回类型{函数体}** 1[](int x,int y)-&gt;int{return x+y}; 有俩个形参，返回类型为int 注意：当返回类型很明确时，lambda函数可以不用尾置指定返回类型 例如： 1[](int x,int y){return x+y}; 返回类型很明确不需要尾置，这也是正确的，也是比较常用的 与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称捕获 常见的捕获有一下几种形式 [x]:以值捕获的方式捕获变量x [=]:以值捕获的方式捕获所有变量 [&amp;x]：以引用捕获的方式捕获变量x [&amp;]:以引用捕获的方式捕获所有变量 回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。 如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。 当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。 这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面 12345678int main(){ int x=15; auto f=[&amp;x](int y)-&gt;int {return (++x)+y;}; x=20; f(5); cout&lt;&lt;x;} 【&amp;x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到 回调函数 在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。 使用functional库的回调函数，可以实现以下功能： 将函数作为参数传递给其他函数，以便在需要的时候调用。 在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。 在函数式编程中，可以使用回调函数来实现高阶函数的操作。 定义：std::function&lt;返回类型（参数类型列表）&gt; 回调函数名 1std::function&lt;void(int)&gt; callback 表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装） 注意：function也是定义在标准函数库里的，所以要声明域名std 基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器 关于植物明星大乱斗中的计时器逻辑分析大体本游戏使用了一下的计时器 123456789Timer timer_invulnerable; //无敌状态定时器Timer timer_invulnerable_blink; //无敌状态闪烁定时器，用于不同序列帧的切换功能Timer timer_attack_cd; //普通攻击冷却定时器Timer timer_run_effect_generation; //跑动粒子特效发射定时器Timer timer_die_effect_generation; //死亡特效例子发射器Timer timer_cursor_visibility; //玩家光标指示器可见性定时器 无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态 闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、 普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成 跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片） 死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成 玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示 例子： 无敌状态定时器1234567891011121314151617181920212223242526272829Timer timer_invulnerable; //无敌状态定时器Player() { //无敌状态定时器的初始化设置 timer_invulnerable.set_wait_time(750); //触发事件间隔750毫秒，0.75秒 timer_invulnerable.set_one_shot(true); //单次触发 timer_invulnerable.set_callback([&amp;]() //设置回调函数 { is_invulnerable = false; });} void on_update() { ..... timer_invulnerable.on_update(delta);//更新 move_and_collide(); //检测触发函数 }void make_invulnerable(){ is_invulnerable = true; //受击状态量改为true timer_invulnerable.restart(); //计时器重置，shotted改为false，事件到达后is_vulnerable改回false} 简单分析一下这里的回调函数 [&amp;](){is_invulnerable=false;} 以引用捕获的方式获取类的局部变量，没有形参，函数主体 大体流程就是这样子的 总结： 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。 相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解 植物明星大乱斗教程","link":"/2024/06/14/%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E5%88%86%E6%9E%90/"}],"tags":[{"name":"c++语法","slug":"c-语法","link":"/tags/c-%E8%AF%AD%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"游戏心得","slug":"游戏心得","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"}],"categories":[{"name":"c++语法","slug":"c-语法","link":"/categories/c-%E8%AF%AD%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"游戏心得","slug":"游戏心得","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"},{"name":"植物明星大乱斗","slug":"植物明星大乱斗","link":"/categories/%E6%A4%8D%E7%89%A9%E6%98%8E%E6%98%9F%E5%A4%A7%E4%B9%B1%E6%96%97/"}],"pages":[]}