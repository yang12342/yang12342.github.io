
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>git基本使用 | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>git基本使用</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/30
        </span>
        
        <span class="category">
            <a href="/categories/git/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                git
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/git/" style="color: #03a9f4">
                    git
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="git-的使用"><a href="#git-的使用" class="headerlink" title="git 的使用"></a>git 的使用</h2><p>在 Git 本地仓库中将你新添加的文件纳入版本控制，通常需要执行以下步骤：</p>
<hr>
<h3 id="步骤-1-检查新文件的状态"><a href="#步骤-1-检查新文件的状态" class="headerlink" title="步骤 1: 检查新文件的状态"></a><strong>步骤 1: 检查新文件的状态</strong></h3><p>运行以下命令查看当前仓库的状态，确保你的新文件未被 Git 跟踪：</p>
<span id="more"></span>

<pre><code>git status
</code></pre>
<p><strong>输出示例</strong>：</p>
<pre><code>Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        new_file.txt
</code></pre>
<p>未追踪的文件会出现在 <code>Untracked files</code> 列表中。</p>
<hr>
<h3 id="步骤-2-添加文件到暂存区"><a href="#步骤-2-添加文件到暂存区" class="headerlink" title="步骤 2: 添加文件到暂存区"></a><strong>步骤 2: 添加文件到暂存区</strong></h3><p>使用 <code>git add</code> 命令将文件添加到暂存区。你有以下几种方式：</p>
<h4 id="添加单个文件："><a href="#添加单个文件：" class="headerlink" title="添加单个文件："></a><strong>添加单个文件</strong>：</h4><pre><code>git add &lt;file_name&gt;
</code></pre>
<p>例如：</p>
<pre><code>git add new_file.txt
</code></pre>
<h4 id="添加多个文件："><a href="#添加多个文件：" class="headerlink" title="添加多个文件："></a><strong>添加多个文件</strong>：</h4><p>如果有多个文件，可以一次性添加：</p>
<pre><code>git add file1.txt file2.txt
</code></pre>
<h4 id="添加所有未追踪文件："><a href="#添加所有未追踪文件：" class="headerlink" title="添加所有未追踪文件："></a><strong>添加所有未追踪文件</strong>：</h4><p>使用通配符 <code>.</code> 添加所有未追踪的文件和修改：</p>
<pre><code>git add .
</code></pre>
<hr>
<h3 id="步骤-3-提交文件到版本库"><a href="#步骤-3-提交文件到版本库" class="headerlink" title="步骤 3: 提交文件到版本库"></a><strong>步骤 3: 提交文件到版本库</strong></h3><p>文件添加到暂存区后，需要提交到版本库：</p>
<pre><code>git commit -m &quot;描述本次添加的文件或修改&quot;
</code></pre>
<p>例如：</p>
<pre><code>git commit -m &quot;添加新文件 new_file.txt&quot;
</code></pre>
<p>当然你也可以全部添加</p>
<pre><code class="CPP">git add *    //添加监管目录下的所有文件
</code></pre>
<hr>
<h3 id="完整操作示例"><a href="#完整操作示例" class="headerlink" title="完整操作示例"></a><strong>完整操作示例</strong></h3><p>假设新添加了一个文件 <code>example.txt</code>，完整操作流程如下：</p>
<pre><code>git status               			#检查文件状态
git add example.txt      			# 将文件添加到暂存区
git commit -m &quot;添加 example.txt&quot;  	# 提交更改
</code></pre>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>忽略不需要的文件</strong>： 如果有文件不需要被追踪，可以在 <code>.gitignore</code> 文件中添加规则：</p>
<p>![image-20241129191002727](.&#x2F;git 的使用&#x2F;image-20241129191002727.png)</p>
<p>然后运行：</p>
<pre><code>git add .gitignore
git commit -m &quot;更新 .gitignore 文件&quot;
</code></pre>
</li>
<li><p><strong>检查提交结果</strong>： 提交后可通过以下命令查看提交记录：</p>
<pre><code>git log
</code></pre>
</li>
</ol>
<p>按照这些步骤，就可以成功将本地添加的文件纳入 Git 的版本管理。</p>
<hr>
<p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p>
<p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有 parent 节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p>
<hr>
<h3 id="Git-Commit-Git-提交"><a href="#Git-Commit-Git-提交" class="headerlink" title="Git Commit Git 提交"></a>Git Commit Git 提交</h3><p>git commit首先就是简单的提交，基于上一个节点往下衍生一个子节点。</p>
<p>格式：</p>
<pre><code class="CPP">git branch 节点名字  创建分支的节点位置（默认为head）
//示例
git branch bugFix HEAD~^2~
</code></pre>
<img src="./git 的使用/image-20241129174343859.png" alt="image-20241129174343859" style="zoom:50%;" />

<p>一般就是（括号是可加可不加）</p>
<pre><code class="CPP">git commit （-m“备注”）		//备注就是提交时候会附带你的更改说明
</code></pre>
<img src="./git 的使用/image-20241129174400853.png" alt="image-20241129174400853" style="zoom:50%;" />

<blockquote>
<p>里面的c2什么的其实是标记的哈希码，是一段很长的字母和数字，一般用前三位就能表示</p>
</blockquote>
<hr>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>分支其实就是一个新的指针。</p>
<p>就是在当前的head节点创建一个分支，最开始的都是main。</p>
<img src="./git 的使用/image-20241129181855232.png" alt="image-20241129181855232" style="zoom: 67%;" />

<p>然后就是</p>
<pre><code class="CPP">git branch newImage //创建一个新的分支（指针）
</code></pre>
<img src="./git 的使用/image-20241129181949193.png" alt="image-20241129181949193" style="zoom: 67%;" />

<p>但是注意head指针依然附在main上所以你提交依然是在main上操作</p>
<pre><code class="CPP">git commit
</code></pre>
<img src="./git 的使用/image-20241129182044002.png" alt="image-20241129182044002" style="zoom:67%;" />

<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>切换head跟踪的分支或者节点</p>
<pre><code class="CPP">git checkout newImage（或者对应节点的哈希值）
</code></pre>
<p>然后我们提交就会如图，在新的分支上提交。</p>
<p>![image-20241129182240750](.&#x2F;git 的使用&#x2F;image-20241129182240750.png)</p>
<p><em>注意：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。 由于现在很多人还无法使用 <code>switch</code>，本次课程仍然使用 <code>checkout</code> 而不是 <code>switch</code>， 但是如果你想尝试一下新命令，我们的应用也是支持的！并且你可以从<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-switch">这里</a>学到更多关于新命令的内容。</em></p>
<p>对了，有个更简洁的方式：如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>
<h3 id="git-checkout-b"><a href="#git-checkout-b" class="headerlink" title="git checkout -b &lt;your-branch-name&gt;"></a><code>git checkout -b &lt;your-branch-name&gt;</code></h3><p>来实现</p>
<hr>
<p>接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”</p>
<p>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”</p>
<hr>
<p>当前处于main分支</p>
<img src="./git 的使用/image-20241129182757083.png" alt="image-20241129182757083" style="zoom:67%;" />

<pre><code class="CPP">git merge bugFix
</code></pre>
<p>表示将bugFix融合至当前的head指向的节点来。如果当前head指向的是一个分支，那么这个分支也会指向新的合并点</p>
<p>这意味着 <code>main</code> 包含了对代码库的所有修改。</p>
<img src="./git 的使用/image-20241129182813530.png" alt="image-20241129182813530" style="zoom:50%;" />

<p>此时我们将main融合至bugFix中，我们会发现Git 什么都不做，只是简单地把 <code>bugFix</code> 移动到 <code>main</code> 所指向的那个提交记录，因为 <code>main</code> 继承自 <code>bugFix</code></p>
<pre><code class="CPp">git checkout bugFix
git merge main
</code></pre>
<img src="./git 的使用/image-20241129183104512.png" alt="image-20241129183104512" style="zoom:50%;" />

<hr>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>第二种合并分支的方法是 <code>git rebase</code></p>
<p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<pre><code class="CPP">git rebase 复制到的目标节点 源节点（默认为head）
</code></pre>
<p>注意如果复制的源节点是分支，那么分支会指向新的复制节点。</p>
<p>但是如果复制到的目标节点如果是分支，他的分支指向的节点是不会变的（就是说我复制到bugFix节点下方，但是bugFix节点是不动的）</p>
<img src="./git 的使用/image-20241129184425956.png" alt="image-20241129184425956" style="zoom:50%;" />

<p>此时我执行</p>
<pre><code class="CPP">git rebase main bugFix
</code></pre>
<p>main不变，bugFix显然变化了（不论head在哪，head是肯定会指向复制的最后一个）</p>
<img src="./git 的使用/image-20241129184517563.png" alt="image-20241129184517563" style="zoom:50%;" />

<p>这样会把俩个节点的不同点，全部复制到目标节点下，这么说可能有点抽象</p>
<p>我们看到如图的结构，我现在执行下面的命令</p>
<p>![image-20241129201851639](.&#x2F;git 的使用&#x2F;image-20241129201851639.png)</p>
<pre><code class="CPP">git rebase bugFix side
</code></pre>
<p>我们就可以看见从side到c4的节点全部复制过来了</p>
<img src="./git 的使用/image-20241129202121638.png" alt="image-20241129202121638" style="zoom:67%;" />

<hr>
<img src="./git 的使用/image-20241129183547683.png" alt="image-20241129183547683" style="zoom:50%;" />

<pre><code class="CPP">git rebase main		//将head此时指向的bugFix分支上的不同点复制到mian下面
</code></pre>
<p>注意此时的head如果指向的是分支，那么分支也会指到新的复制点上</p>
<img src="./git 的使用/image-20241129183651149.png" alt="image-20241129183651149" style="zoom:50%;" />

<p>假设此时将head指向main，然后复制到bugFix，他会复制吗。</p>
<pre><code class="CPp">git checkout main
git rebase bugFix
</code></pre>
<p>答案是不会，只会将main指向bugFix指向的节点，因为bugFix继承mian</p>
<p>![image-20241129183924357](.&#x2F;git 的使用&#x2F;image-20241129183924357.png)</p>
<hr>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>我们首先看一下 “HEAD”。 HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<blockquote>
<p>记住，如果是单纯的push，head是不能从分支上分离。当然也有分离提交的方法</p>
</blockquote>
<p>我们执行下面的方式,可以看到，此时HEAD就是<strong>分离</strong>出来了</p>
<pre><code class="CPP">git checkout  c2
</code></pre>
<img src="./git 的使用/image-20241129184859340.png" alt="image-20241129184859340" style="zoom: 67%;" />

<hr>
<h3 id="相对引用-和"><a href="#相对引用-和" class="headerlink" title="相对引用^和~"></a>相对引用<code>^</code>和<code>~</code></h3><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，可不像示例的c1，c2。是非常复杂的哈希值，我们必须使用<code>git log</code>去查询提交记录和哈希值（例如<code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>）。</p>
<p>Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>
<p>正如前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<ul>
<li>使用 <code>^</code> 向上移动 1 个提交记录</li>
<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>
</ul>
<blockquote>
<p>二者还是有差别的，后面会介绍的</p>
</blockquote>
<p>所以 <code>main^</code> 相当于“<code>main</code> 的 parent 节点”。</p>
<p><code>main^^</code> 是 <code>main</code> 的第二个 parent 节点</p>
<p>现在咱们切换到 main 的 parent 节点，此时HEAD就指向了父节点</p>
<pre><code class="CPP">git checkout main^
</code></pre>
<img src="./git 的使用/image-20241129185309862.png" alt="image-20241129185309862" style="zoom:67%;" />

<p>你也可以将 <code>HEAD</code> 作为相对引用的参照。下面咱们就用 <code>HEAD</code> 在提交树中向上移动几次。</p>
<pre><code class="CPP">git checkout head^^	//指移动俩次
</code></pre>
<hr>
<h3 id="“-”操作符"><a href="#“-”操作符" class="headerlink" title="“~”操作符"></a>“~”操作符</h3><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p>
<img src="./git 的使用/image-20241129185517916.png" alt="image-20241129185517916" style="zoom:67%;" />

<p>然后我们移动四次，直接移动到c0</p>
<pre><code class="CPP">git checkout HEAD~4
</code></pre>
<img src="./git 的使用/image-20241129185555878.png" alt="image-20241129185555878" style="zoom: 67%;" />

<h3 id="选择-parent-提交记录"><a href="#选择-parent-提交记录" class="headerlink" title="选择 parent 提交记录"></a>选择 parent 提交记录</h3><p>操作符 <code>^</code>并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>
<img src="./git 的使用/image-20241129202655086.png" alt="image-20241129202655086" style="zoom: 67%;" />

<p>如果我们想回到c1</p>
<pre><code class="CPP">git checkout main^
</code></pre>
<img src="./git 的使用/image-20241129202734490.png" alt="image-20241129202734490" style="zoom:67%;" />

<p>但是如果我们想要回到c2，就要使用下面的指令</p>
<pre><code class="CPP">git checkout main^2
</code></pre>
<img src="./git 的使用/image-20241129202824043.png" alt="image-20241129202824043" style="zoom:67%;" />

<p>这些操作符还支持链式操作！试一下这个：</p>
<pre><code class="CPP">git checkout HEAD~^2~2  //往上一个，选择父节点2，再次往上俩个
</code></pre>
<h3 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。</p>
<pre><code class="CPP">git branch -f 分支名字 分支指向的节点位置（可以是节点，也可以相对引用的位置，也可以是别的分支）
</code></pre>
<p>例如:</p>
<pre><code>git branch -f main HEAD~3
</code></pre>
<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。</p>
<img src="./git 的使用/image-20241129190022088.png" alt="image-20241129190022088" style="zoom: 67%;" />

<hr>
<h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>
<h2 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h2><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<img src="./git 的使用/image-20241129191301894.png" alt="image-20241129191301894" style="zoom:50%;" />

<p>Git 把 main 分支移回到 <code>C1</code>；现在我们的本地代码库根本就不知道有 <code>C2</code> 这个提交了。</p>
<p>（在reset后， <code>C2</code> 所做的变更还在，就是你目前本地库的代码依然是修改过后的，但是只不过main指向的，但是处于未加入暂存区状态。）</p>
<pre><code class="CPP">git reset HEAD~1
</code></pre>
<img src="./git 的使用/image-20241129191524229.png" alt="image-20241129191524229" style="zoom:67%;" />

<p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！我们是无法提交这种更改的，因为假设远程仓库不可能让你去动已经是中间节点的c1，在远程仓库c1已经被继承过了，所以无法推送。</p>
<h2 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h2><p>所以我们将回撤的节点作为新的提交推送就行了。</p>
<pre><code class="CPP">git revert HEAD
</code></pre>
<img src="./git 的使用/image-20241129191628824.png" alt="image-20241129191628824" style="zoom:67%;" />

<p>我们可以看到不想reset，我们而是拥有了一个新的提交，是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code> 是相同的。</p>
<p>这样之后，我们就可以推送到远程仓库</p>
<hr>
<h2 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h2><p>然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>
<p>看起来挺复杂, 其实是个很简单的概念。</p>
<hr>
<h2 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h2><p>本系列的第一个命令是 <code>git cherry-pick</code>, 命令形式为:</p>
<pre><code class="CPP">git cherry-pick 节点1 节点2 ...(按顺序复制到head下方)
</code></pre>
<img src="./git 的使用/image-20241129192654894.png" alt="image-20241129192654894" style="zoom: 67%;" />

<p>这里有一个仓库, 我们想将 <code>side</code> 分支上的工作复制到 <code>main</code> 分支，你立刻想到了之前学过的 <code>rebase</code> 了吧？但是咱们还是看看 <code>cherry-pick</code> 有什么本领吧。</p>
<pre><code class="CPP">git cherry-pick c2 c4
</code></pre>
<p>就是在当前的分支下面复制c2和c4的提交，按顺序写。</p>
<p>（如果head指向是一个分支（未分离状态），那么分支也会随着复制向下走，head是肯定会指向复制的最后一个）</p>
<img src="./git 的使用/image-20241129192736774.png" alt="image-20241129192736774" style="zoom:50%;" />

<hr>
<h2 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h2><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>
<pre><code class="CPP">git rebase -i 你需要回溯到的节点 开始的节点（默认为head）
</code></pre>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li>
</ul>
<img src="./git 的使用/image-20241129193423389.png" alt="image-20241129193423389" style="zoom:80%;" />

<pre><code class="cpp">git rebase -i HEAD~4
</code></pre>
<p>教程就会出现这样的UI，供你重新调整，或者丢弃。注意我回溯4的节点，但是注意最后一个c1是不包含在下面的修改列表。</p>
<img src="./git 的使用/image-20241129193502882.png" alt="image-20241129193502882" style="zoom: 50%;" />

<p>随后就是从c1，重新创建分支将修改后进行复制成如图的逻辑。</p>
<p>（注意此时不管head在哪里，head都会指向此操作后最后一个，此处的c4‘）</p>
<p>![image-20241129193649249](.&#x2F;git 的使用&#x2F;image-20241129193649249.png)</p>
<hr>
<h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<ul>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ul>
<p>来达到目的，实现一个如图的效果</p>
<pre><code class="CPP">git checkout main
git cherry-pick bugFix
</code></pre>
<img src="./git 的使用/image-20241129194043401.png" alt="image-20241129194043401" style="zoom:67%;" />

<h2 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h2><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>(就是想修改一下父节点)</p>
<p>我们可以通过下面的方法来克服困难：</p>
<ul>
<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>
<li>然后用 <code>git commit --amend</code> 来进行一些小修改（仅仅限于此教程）</li>
<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>
</ul>
<blockquote>
<p>本质上还是因为推送到远程仓库只能基于最前端节点修改</p>
</blockquote>
<h2 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h2><p>我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。</p>
<p>其实就是利用</p>
<pre><code>cherry-pick
</code></pre>
<p>去调换顺序修改</p>
<hr>
<h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>咱们先建立一个标签，指向提交记录 <code>C1</code>，表示这是我们 1.0 版本。</p>
<pre><code class="CPP">git tag v1 c1
</code></pre>
<p>我们将这个标签命名为 <code>v1</code>，并且明确地让它指向提交记录 <code>C1</code>，如果你不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p>
<img src="./git 的使用/image-20241129200645385.png" alt="image-20241129200645385" style="zoom:67%;" />

<h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p><code>git describe</code> 的语法是：</p>
<pre><code>git describe &lt;ref&gt;
</code></pre>
<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<pre><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;
</code></pre>
<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 交记录上有某个标签时，则只输出标签名称</p>
<p>![image-20241129200955580](.&#x2F;git 的使用&#x2F;image-20241129200955580.png)</p>
<p>对这个图使用</p>
<pre><code class="CPP">git describe main
</code></pre>
<p>输出</p>
<pre><code class="CPP">v1_2_gC2    //最近的标签，差俩个提交，main是c2
</code></pre>
<hr>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
