
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>空洞武士笔记2 | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>空洞武士笔记2</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/23
        </span>
        
        <span class="category">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                设计经验
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/cpp/" style="color: #00a596">
                    cpp
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/" style="color: #03a9f4">
                    游戏设计
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="资源管理器的资源管理设置"><a href="#资源管理器的资源管理设置" class="headerlink" title="资源管理器的资源管理设置"></a>资源管理器的资源管理设置</h2><p>关于对于资源文件的加载，在之前的项目都是通过硬编码的方式手写出所有路径加载对应的图片和音频资源。</p>
<p>相对于之前，我们使用<strong>stl</strong>的<unordered_map>来存储对应的资源</p>
<span id="more"></span>

<pre><code class="CPP">#include &lt;string&gt;
#include &lt;graphics.h&gt;
#include &lt;unordered_map&gt;


class ResourcesManager
&#123;
public:
    static ResourcesManager* instance();

    void load();

    Atlas* find_atlas(const std::string&amp; id)const;
    IMAGE* find_image(const std::string&amp; id)const;

private:
    static ResourcesManager* manager;

    std::unordered_map&lt;std::string, Atlas*&gt; atlas_pool;
    std::unordered_map&lt;std::string, IMAGE*&gt; image_pool;
private:
    ResourcesManager();
    ~ResourcesManager();

    void flip_image(IMAGE* src_image, IMAGE* dst_image, int num_h = 1);
    void flip_image(const std::string&amp; src_id, const std::string dst_id, int num_h = 1);
    void flip_atlas(const std::string&amp; src_id, const std::string dst_id);

&#125;;
</code></pre>
<p>我们创建了对应的<strong>图集资源池和图片资源池</strong>放置对应的美术资产。</p>
<p>由于音频文件在加载的时候会自动附加上对应的名称，所以我们无需创建对应的资源池管理音频资源</p>
<p>同时我么提够了对应的加载函数和翻转函数</p>
<blockquote>
<p>资源池注意我们是的value都是指针对象，如果是对象本身可能在放入的时候复制啥的造成内存浪费，所以资源加载后最好都是指针调用，防止资源占用过多内存</p>
</blockquote>
<p>接下来我们看一下实现</p>
<h4 id="1-atlas和image的加载"><a href="#1-atlas和image的加载" class="headerlink" title="1.atlas和image的加载"></a>1.atlas和image的加载</h4><p>首先我们先创建俩个资源路径结构体，并于我们将路径资源和对应的资源池构建联系，而不是后面遇到一个重新写一个</p>
<pre><code class="CPP">struct ImageResInfo
&#123;
    std::string id;				//这是放置到image_pool的key（string）
    LPCTSTR path;				//这是对应的资源加载路径
&#125;;

struct AtlasResInfo				
&#123;
    std::string id;				//这是Atlas_pool的key（string）
    LPCTSTR path;				//对应的资源加载路径
    int num_frame = 0;			//由于是散装的图片，我们需要数量来创建对应的atlas
&#125;;
</code></pre>
<p>然后我们创建对应的信息列表（利用vector），表明我们资源池和加载路径的关系</p>
<pre><code class="CPP">static const std::vector&lt;ImageResInfo&gt; image_info_list =
&#123;
    &#123;&quot;background&quot;,	_T(R&quot;(resources\background.png)&quot;)&#125;,
    &#123;&quot;ui_heart&quot;,	_T(R&quot;(resources\ui_heart.png)&quot;)&#125;,
&#125;;

static const std::vector&lt;AtlasResInfo&gt; atlas_info_list =
&#123;
    &#123;&quot;barb_break&quot;,		_T(R&quot;(resources\enemy\barb_break\%d.png)&quot;),		3&#125;,
    &#123;&quot;barb_loose&quot;,		_T(R&quot;(resources\enemy\barb_loose\%d.png)&quot;),		5&#125;,
&#125;;
</code></pre>
<p>随后我们便可以在load函数中利用循环遍历信息列表来加载对应的资源以及放入对应的资源池中去</p>
<pre><code class="CPP">void ResourcesManager::load()
&#123;
    for (const auto&amp; info : image_info_list)
    &#123;
        IMAGE* image = new IMAGE();
        loadimage(image, info.path);			//加载资源
        if (!check_image_valid(image))			//如果对应的image不存在会返回空指针，表明路径错误报错
            throw info.path;
        image_pool[info.id] = image;			//将对应的资源放入资源池中
    &#125;

    for (const auto&amp; info : atlas_info_list)
    &#123;
        Atlas* atlas = new Atlas();
        atlas-&gt;load(info.path, info.num_frame);
        for (int i = 0; i &lt; atlas-&gt;get_size(); i++)		//利用命名规律加载对应的的资源
        &#123;
            IMAGE* image = atlas-&gt;get_image(i);
            if (!check_image_valid(image))
                throw info.path;
        &#125;
        atlas_pool[info.id] = atlas;
    &#125;
&#125;
</code></pre>
<h4 id="2-图片的翻转的注意"><a href="#2-图片的翻转的注意" class="headerlink" title="2.图片的翻转的注意"></a>2.图片的翻转的注意</h4><p>显然我们要针对image（多动画帧的一张图片）和atlas（散装动画图集）。</p>
<p>首先二者本质都是对image的翻转</p>
<p>关键是对于连续动画帧的翻转，我们肯定不能将整张图片翻转，不然播放顺序会倒过来，导致我们又需要更改Animation的frame加载或者播放逻辑，所以我们选择翻转的时候选择对应的裁剪区域</p>
<pre><code class="CPP">void ResourcesManager::flip_image(IMAGE* src_image, IMAGE* dst_image, int num_h)
&#123;
    int w = src_image-&gt;getwidth();
    int h = src_image-&gt;getheight();
    int w_frame = w / num_h;

    Resize(dst_image, w, h);
    DWORD* src_buffer = GetImageBuffer(src_image);
    DWORD* dst_buffer = GetImageBuffer(dst_image);

    //对每个对应的动作裁剪区域翻转
    for (int i = 0; i &lt; num_h; i++)
    &#123;
        int x_left = i * w_frame;
        int x_right = (i + 1) * w_frame;

        for (int y = 0; y &lt; h; y++)
        &#123;
            for (int x = x_left; x &lt; x_right; x++)
            &#123;
                int idx_src = y * w + x;
                int idx_dst = y * w + x_right - (x - x_left);
                dst_buffer[idx_dst] = src_buffer[idx_src];
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>对应的<strong>num_h</strong>就是我们对应图片有几个动画帧，显然atlas使用默认为1。</p>
<p>翻转逻辑上，也是使用了IMAGE像素数组缓冲区的逻辑，每一个像素都是BYTE的32位二进制的RGBA构成的。</p>
<blockquote>
<p>注意再easyX中，我们的image在new 的时候不会分配储存空间。</p>
<p>所以easyX提供了一个方法，帮助我们分配对应的空间，参数（image*，像素宽度，像素高度）；</p>
</blockquote>
<p>所以根据上面的方法我们向上再封装一层</p>
<p>atlas和image的翻转函数，用于资源加载load函数的时候使用</p>
<pre><code class="CPP">void ResourcesManager::flip_image(const std::string&amp; src_id, const std::string dst_id, int num_h)
&#123;
    IMAGE* src_image = image_pool[src_id];
    IMAGE* dst_image = new IMAGE();

    flip_image(src_image, dst_image, num_h);
    image_pool[dst_id] = dst_image;
&#125;

void ResourcesManager::flip_atlas(const std::string&amp; src_id, const std::string dst_id)
&#123;
    Atlas* src_atlas = atlas_pool[src_id];
    Atlas* dst_atlas = new Atlas();
    for (int i = 0; i &lt; src_atlas-&gt;get_size(); i++)
    &#123;
        IMAGE img_flipped;
        flip_image(src_atlas-&gt;get_image(i), &amp;img_flipped);
        dst_atlas-&gt;add_image(img_flipped);
    &#125;

    atlas_pool[dst_id] = dst_atlas;
&#125;
</code></pre>
<h4 id="3-对于音频资源的加载"><a href="#3-对于音频资源的加载" class="headerlink" title="3.对于音频资源的加载"></a>3.对于音频资源的加载</h4><p>我们在util.h的文件提供了三个音频函数</p>
<pre><code class="CPP">inline void load_audio(LPCTSTR path, LPCTSTR id)
&#123;
    static TCHAR str_cmd[512];
    _stprintf_s(str_cmd, _T(&quot;open %s alias %s&quot;), path, id);
    mciSendString(str_cmd, NULL, 0, NULL);
&#125;

inline void play_audio(LPCTSTR id, bool is_loop = false)
&#123;
    static TCHAR str_cmd[512];
    _stprintf_s(str_cmd, _T(&quot;play %s %s from 0&quot;), id, is_loop ? _T(&quot;repeat&quot;) : _T(&quot;&quot;));
    mciSendString(str_cmd, NULL, 0, NULL);
&#125;

inline void stop_audio(LPCTSTR id)
&#123;
    static TCHAR str_cmd[512];
    _stprintf_s(str_cmd, _T(&quot;stop %s&quot;), id);
    mciSendString(str_cmd, NULL, 0, NULL);
&#125;
</code></pre>
<p>加载的时候对应的音频文件就会产生对应的id，这就是我们目前不使用资源池的原因。</p>
<p>我们使用_stprintf_s（）创建对应的指令信息，然后调用mciSendString的执行对应指令</p>
<p>因此加载音频资源如下即可</p>
<pre><code class="CPP">load_audio(_T(R&quot;(resources\audio\bgm.mp3)&quot;), _T(&quot;bgm&quot;));
load_audio(_T(R&quot;(resources\audio\barb_break.mp3)&quot;), _T(&quot;barb_break&quot;));
load_audio(_T(R&quot;(resources\audio\bullet_time.mp3)&quot;), _T(&quot;bullet_time&quot;));
</code></pre>
<hr>
<h3 id="利用filesystem对文件资源进行加载"><a href="#利用filesystem对文件资源进行加载" class="headerlink" title="利用filesystem对文件资源进行加载"></a>利用filesystem对文件资源进行加载</h3><p>会补充一篇关于filesystem的文章</p>
<img src="./image-20240917212326738.png" alt="image-20240917212326738" style="zoom:50%;" />

<p>因为我放弃了使用信息列表所以缺少了资源池的对应关系，所以我将图片或动画文件名字改为资源池对应的id</p>
<p><img src="/./%E7%A9%BA%E6%B4%9E%E6%AD%A6%E5%A3%AB%E7%AC%94%E8%AE%B02/image-20240917212433693.png" alt="image-20240917212433693"></p>
<img src="./屏幕截图 2024-09-17 212425.png" style="zoom:50%;" />

<p>这样我就可以通过路径中的文件名作为id来上传到资源池管理</p>
<pre><code class="CPP">fs::path resourceDir = &quot;resources&quot;;

// 遍历目录
for (const auto&amp; entry : fs::directory_iterator(resourceDir)) &#123;
    if (entry.is_regular_file()) 
    &#123; // 确保是文件而不是子目录
        IMAGE* image = new IMAGE();
        loadimage(image, entry.path().wstring().c_str());
        if (!check_image_valid(image))
            throw entry.path().wstring().c_str();
        image_pool[entry.path().stem().string()] = image;
    &#125;
    else
    &#123;
        fs::path filePath = entry.path();
        if (filePath.filename() == &quot;player&quot;)
        &#123;
            
            for (const auto&amp; m_entry : fs::directory_iterator(filePath))
            &#123;
                IMAGE* image = new IMAGE();
                loadimage(image,m_entry.path().wstring().c_str());
                if (!check_image_valid(image))
                    throw m_entry.path().wstring().c_str();
                image_pool[m_entry.path().stem().string()] = image;
            &#125;
        &#125;
        else if (filePath.filename() == &quot;enemy&quot;)
        &#123;
            for (const auto&amp; m_entry : fs::directory_iterator(filePath))
            &#123;
                Atlas* atlas = new Atlas();
                atlas-&gt;load(m_entry.path());
                for (int i = 0; i &lt; atlas-&gt;get_size(); i++)
                &#123;
                    IMAGE* image = atlas-&gt;get_image(i);
                    if (!check_image_valid(image))
                        throw m_entry.path().wstring().c_str();
                &#125;
                
                atlas_pool[m_entry.path().filename().string()] = atlas;
            &#125;
        &#125;
        else if (filePath.filename() == &quot;audio&quot;)
        &#123;
            for (const auto&amp; m_entry : fs::directory_iterator(filePath))
            &#123;
                load_audio(m_entry.path().wstring().c_str(), m_entry.path().stem().wstring().c_str());
            &#125;
        &#125;
        
    &#125;
&#125;
</code></pre>
<p>首先遍历resources目录</p>
<p>如果是player，那么是image多帧图片，我们就可以遍历player文件夹的所有图片加载并且将名字作为资源池id</p>
<p>如果是enemy我们重载了atlas的load（）函数，接受filepath作为参数，加载对应的一个动画</p>
<pre><code class="CPP">    void load(fs::path filePath)
    &#123;
        img_list.clear();
        int num = std::distance(fs::directory_iterator(filePath), fs::directory_iterator&#123;&#125;);//计算帧数
        img_list.resize(num);

        int i = 0;
        for (const auto&amp; m_entry : fs::directory_iterator(filePath))
        &#123;
            loadimage(&amp;img_list[i], m_entry.path().wstring().c_str());
            i++;
        &#125;
    &#125;
</code></pre>
<p>如果是单独的图片，那么就直接加载放进资源池</p>
<p>如果是audio，则遍历加载和图片同理</p>
<blockquote>
<p>LPCTSTR<br>string</p>
<p>wstring</p>
<p>char</p>
<p>w_char</p>
<p>ANSL</p>
<p>Unicode</p>
<p>这些关系可以写一下</p>
</blockquote>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
