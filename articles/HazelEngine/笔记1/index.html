
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>引擎项目环境配置 | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>引擎项目环境配置</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/22
        </span>
        
        <span class="category">
            <a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                游戏引擎
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" style="color: #03a9f4">
                    游戏引擎
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="HazelEngine笔记1"><a href="#HazelEngine笔记1" class="headerlink" title="HazelEngine笔记1"></a>HazelEngine笔记1</h1><h3 id="1-项目配置"><a href="#1-项目配置" class="headerlink" title="1.项目配置"></a>1.项目配置</h3><p>在vs中创建Hazel项目，然后打开“项目属性 -&gt;  配置属性 -&gt; 常规”中设置一下 </p>
<ul>
<li>配置类型： 选择**.dll**</li>
</ul>
<blockquote>
<p>在配置为Dynamic Library时，项目输出的文件是一个DLL文件，其他程序可以在运行时加载和使用它。通常会生成一个<code>.dll</code>文件和一个对应的<code>.lib</code>文件（用于在编译时链接DLL）。</p>
<p><strong>DLL (Dynamic Link Library)</strong> 是包含可执行代码和数据的二进制文件，在程序运行时动态加载到内存中。</p>
<p>DLL文件中包含的代码和资源在程序<strong>运行时</strong>才会被加载使用，因此在编译和链接阶段，它不会直接参与到应用程序的构建中。</p>
<p>对于使用DLL的项目来说，<strong>LIB文件</strong>并不是静态链接库，而是一个“<strong>导入库</strong>”（import library）。这个LIB文件不包含DLL的实际实现代码，而是包含指向DLL中的函数或数据的引用和符号信息。</p>
<p>当你在Visual Studio中设置项目生成DLL时，Visual Studio同时会生成一个对应的LIB文件。这个LIB文件的作用是告诉链接器：当其他项目引用此库时，链接器应如何找到和使用对应的DLL中的函数和数据。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>设置hazel项目的生成的<strong>输出目录和生成目录</strong></li>
</ul>
<p><strong>输出目录</strong>：$(SolutionDir)bin\$(Configuration)-$(Platform)\$(Project)</p>
<p><strong>中间目录</strong>：$(SolutionDir)bin-int\$(Configuration)-$(Platform)\$(Project)</p>
<p><strong>中间目录的最终表达路径</strong>：【C:\Users\86182\Desktop\openGL\Hazel_Engine\Hazel\bin-int\Debug-windows-x86_64】</p>
<blockquote>
<p>关于项目路径的常见的宏，类似的如下，查询也是非常方便</p>
<p><strong><code>$(SolutionDir)</code></strong></p>
<ul>
<li>表示：解决方案文件（<code>.sln</code> 文件）所在的目录（即根目录）。</li>
<li>例子：如果解决方案文件位于 <code>C:\Projects\MySolution\MySolution.sln</code>，那么 <code>$(SolutionDir)</code> 将展开为 <code>C:\Projects\MySolution\</code>。</li>
</ul>
<p><strong>好处</strong>：就是项目方便移植，宏会实时获取一些地址，方便项目在其他电脑等运行。</p>
</blockquote>
<hr>
<img src="./image-20241020131823398.png" alt="Hazel项目的输出目录" style="zoom:50%;" />

<p><strong>输出目录</strong> 是项目编译和链接后的最终产物存放的目录，通常用于存储可执行文件（<code>.exe</code>）、动态链接库（<code>.dll</code>）、静态库（<code>.lib</code>）等。</p>
<ul>
<li><p><strong>.lib和.dll</strong>我们上面都解释过了</p>
</li>
<li><p><code>pdb</code> 文件是 <strong>Program Database</strong>（程序数据库）文件，用于存储调试信息。它由编译器和链接器在编译和链接过程中生成，帮助开发者在调试时能够更好地理解和分析代码的执行情况。</p>
</li>
<li><p><code>.exp</code> 文件是 <strong>Export File</strong>（导出文件），它是在生成动态链接库（DLL）或者链接某些动态库时生成的文件，它存储 DLL 中导出的符号信息，并用于生成 <code>.lib</code> 文件。它存储的是<strong>导出的函数和符号信息</strong>，并在某些情况下协助链接器处理动态库的符号解析。</p>
</li>
</ul>
<img src="./笔记1/image-20241020134433561.png" alt="项目生成的中间目录" style="zoom:50%;" />

<p><strong>中间目录</strong> 是编译过程中存放临时文件和中间文件的目录，通常是为了加速编译过程或生成最终输出文件时的辅助文件。中间目录中的文件是编译的中间产物，不是最终生成的可执行文件或库文件。</p>
<ul>
<li><p><code>.obj</code> 文件：由编译器生成的目标文件（Object files），是源代码编译后的机器代码，但还未链接成最终的可执行文件或库。</p>
</li>
<li><p><code>.pch</code> 文件：预编译头文件（Precompiled Headers），用于加速编译速度。它将头文件的编译结果缓存下来，避免每次都重新编译。</p>
</li>
<li><p><code>.tlog</code> 文件：生成日志文件，记录了每次编译或链接时的详细过程。</p>
</li>
<li><p><code>.idb</code> 文件：增量编译数据库文件，用于加速增量编译。</p>
</li>
</ul>
<hr>
<h4 id="将Hazel加入Sandbox的引用"><a href="#将Hazel加入Sandbox的引用" class="headerlink" title="将Hazel加入Sandbox的引用"></a>将Hazel加入Sandbox的引用</h4><img src="./image-20241020141709283.png"/>

<p>这里添加对Hazel的引用，这样就会自动导入对Hazel生成的.lib库了（应该是添加了寻找路径），最后只要将dll文件放在Sandbox项目下就可以使用了</p>
<hr>
<h5 id="declspec-dllexport-和-declspec-dllimport"><a href="#declspec-dllexport-和-declspec-dllimport" class="headerlink" title="_declspec(dllexport)和__declspec(dllimport)"></a>_declspec(dllexport)和__declspec(dllimport)</h5><h3 id="符号导出"><a href="#符号导出" class="headerlink" title="符号导出"></a>符号导出</h3><ul>
<li><strong>导出</strong>（Export）是指将某个函数或变量从 DLL 中暴露出来，使得其他模块能够访问和使用它。</li>
<li>当你在 DLL 中定义一个函数并使用 <code>__declspec(dllexport)</code> 修饰时，编译器会将该函数的名称和其他相关信息（如参数类型、返回类型等）添加到 DLL 的导出表中。</li>
<li>导出表是 DLL 内部的一个数据结构，列出了所有可以被外部模块调用的函数和变量的信息。</li>
</ul>
<h3 id="符号导入"><a href="#符号导入" class="headerlink" title="符号导入"></a>符号导入</h3><ul>
<li><strong>导入</strong>（Import）是指从 DLL 中使用已经导出的符号（如函数、变量或类）。</li>
<li>当你在一个项目中使用 <code>__declspec(dllimport)</code> 修饰符时，编译器会查看相应的 DLL 的导出表，以获取符号的信息，以便在运行时正确地调用这些符号。</li>
<li>导入时，编译器会生成适当的调用代码，确保在调用函数时使用 DLL 中的实现。</li>
</ul>
<hr>
<h5 id="命名空间namespace"><a href="#命名空间namespace" class="headerlink" title="命名空间namespace"></a>命名空间namespace</h5><p>在跟随这个项目的过程中，发现引擎项目有自己独立的命名空间</p>
<p><em>namespace Hazel{}</em></p>
<hr>
<h4 id="Hazel项目中的函数规范的导入和导出"><a href="#Hazel项目中的函数规范的导入和导出" class="headerlink" title="Hazel项目中的函数规范的导入和导出"></a>Hazel项目中的函数规范的导入和导出</h4><ul>
<li>在Hazel项目中编写一个Core.h文件</li>
</ul>
<pre><code class="CPP">#pragma once


#ifdef  HZ_PLATFORM_WINDOWS
    #ifdef HAZEL_BUILD_DLL
        #define HAZEL_API __declspec(dllexport)
    #else 
        #define HAZEL_API __declspec(dllimport)
    #endif // HZ_BUILD_DLL
#else
    #error Hazel only supports windows!

#endif //  HZ_PLATFORM_WINDOWS
</code></pre>
<p>为了避免在Hazel和app项目中重复写导入导出，我们就选择的利用宏处理简化这个过程，就是利用声明的.h文件和宏一次性解决。</p>
<img src="./笔记1/image-20241020191118332.png" alt="image-20241020191118332" style="zoom:50%;" />

<p>在Hazel项目中，我们在项目属性的预处理器中加入我们需要定义的宏<strong>HAZEL_BUILD_DLL</strong>，<strong>HZ_PLATFORM_WINDOWS</strong>。因为Hazel是导出的dll文件需要选择第一个编译选项。</p>
<p>而在app项目中我们显然不预定义<strong>HAZEL_BUILD_DLL</strong>，就是选择将宏<strong>HAZEL_API</strong>翻译为导入。</p>
<p>这样我们只需要在各自的项目中引入导出目标的头文件，二者都可以使用，但是处理后的结果就适合各自使用了，Hazel是导出，而app内则是导入。</p>
<img src="./image-20241020191613945.png" alt="Hazel项目需要导出的类" />

<img src="./image-20241020191639784.png" alt="包含所有需要的头文件" style="zoom: 50%;" />

<hr>
<h4 id="文件引用的搜索路径问题"><a href="#文件引用的搜索路径问题" class="headerlink" title="文件引用的搜索路径问题"></a>文件引用的搜索路径问题</h4><h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号 &lt; &gt;"></a><strong>尖括号 <code>&lt; &gt;</code></strong></h3><ul>
<li><strong>用途</strong>：通常用于引用<strong>系统库</strong>或<strong>标准库</strong>中的头文件。</li>
<li><strong>搜索路径</strong>：编译器在包含路径的系统目录中（如标准库或编译器的默认路径）查找这些头文件。通常不会在项目目录中查找。</li>
</ul>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号 &quot; &quot;"></a><strong>双引号 <code>&quot; &quot;</code></strong></h3><ul>
<li><strong>用途</strong>：用于引用<strong>用户自定义的头文件</strong>或<strong>项目内的头文件</strong>。</li>
<li><strong>搜索路径</strong>：编译器首先在当前源文件的目录中查找头文件，然后才会到系统目录中查找。这意味着如果你在项目中有与标准库同名的头文件，编译器会优先使用项目中的头文件。</li>
</ul>
<p>二者其实差别不是很大，都可以在引入的时候带一些路径，主要是系统目录的设置。</p>
<img src="./笔记1/image-20241020192835707.png" alt="image-20241020192835707" style="zoom:50%;" />

<p>在项目属性页面的附加包含目录中，我们可以在其中设置系统目录的一些查找路径，有时候引入就会轻松一点，当然起点肯定时当前的项目目录。</p>
<p>要是引入其他项目头文件，就需要类似**..\Hazel\vendor\spdlog\include;**回退到解决方案目录之类的。</p>
<hr>
<h4 id="当生成Hazel的dll文件，记得将dll文件放入app输出文件所在内供其使用。"><a href="#当生成Hazel的dll文件，记得将dll文件放入app输出文件所在内供其使用。" class="headerlink" title="当生成Hazel的dll文件，记得将dll文件放入app输出文件所在内供其使用。"></a>当生成Hazel的dll文件，记得将dll文件放入app输出文件所在内供其使用。</h4><img src="./image-20241020193722241.png" alt="image-20241020193722241" style="zoom:50%;" />

<p>注意路径和位置的相关关系。</p>
<hr>
<h5 id="用-int-main-int-argc-char-argv-来接受命令行参数相比于普通的-int-main-有一些显著的方便之处，特别是对于特定应用场景。以下是它的好处以及为什么有时我们选择更简单的-int-main-："><a href="#用-int-main-int-argc-char-argv-来接受命令行参数相比于普通的-int-main-有一些显著的方便之处，特别是对于特定应用场景。以下是它的好处以及为什么有时我们选择更简单的-int-main-：" class="headerlink" title="用 int main(int argc, char** argv) 来接受命令行参数相比于普通的 int main() 有一些显著的方便之处，特别是对于特定应用场景。以下是它的好处以及为什么有时我们选择更简单的 int main()："></a>用 <code>int main(int argc, char** argv)</code> 来接受命令行参数相比于普通的 <code>int main()</code> 有一些显著的方便之处，特别是对于特定应用场景。以下是它的好处以及为什么有时我们选择更简单的 <code>int main()</code>：</h5><h3 id="1-接受和处理命令行参数"><a href="#1-接受和处理命令行参数" class="headerlink" title="1. 接受和处理命令行参数"></a>1. <strong>接受和处理命令行参数</strong></h3><ul>
<li><p><strong>更灵活的程序控制</strong>：通过 <code>argc</code> 和 <code>argv</code>，你可以从命令行接受参数来控制程序的行为。这对于编写灵活的、可配置的程序非常有用。用户可以通过传递不同的参数让程序在不同的条件下执行不同的操作，而不需要修改代码。</p>
</li>
<li><p>**<code>argc</code>**：全称是 <strong>argument count</strong>，表示传递给程序的命令行参数的个数。包括程序名称本身，所有参数的数量都会包含在 <code>argc</code> 中。</p>
</li>
<li><p><code>argv</code>：全称是 <strong>argument vector</strong>，是一个指向字符指针数组的指针，表示命令行传递的所有参数。</p>
<pre><code>argv[0] 是程序的名称，
</code></pre>
<pre><code>argv[1] 到 argv[argc-1] 是传递给程序的各个命令行参数。
</code></pre>
<ul>
<li><code>argv</code> 本质上是一个 <code>char*</code> 数组，即每个命令行参数都是一个字符串。</li>
<li><code>argv[0]</code>：保存的是程序的名称或路径。</li>
<li><code>argv[1]</code> 到 <code>argv[argc-1]</code>：保存的是传递给程序的参数（如果有的话）。</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设运行以下命令：</p>
<pre><code>bash
./my_program input.txt 42
</code></pre>
<p>则：</p>
<ul>
<li><code>argc</code> &#x3D; 3（表示有三个参数：程序名 <code>./my_program</code>，参数 <code>input.txt</code> 和参数 <code>42</code>）。</li>
<li><code>argv[0]</code> &#x3D; <code>&quot;./my_program&quot;</code> （程序名称）。</li>
<li><code>argv[1]</code> &#x3D; <code>&quot;input.txt&quot;</code> （传递的第一个参数）。</li>
<li><code>argv[2]</code> &#x3D; <code>&quot;42&quot;</code> （传递的第二个参数）。</li>
</ul>
<h4 id="2-接收和处理命令行参数"><a href="#2-接收和处理命令行参数" class="headerlink" title="2. 接收和处理命令行参数"></a>2. 接收和处理命令行参数</h4><p><code>argc</code> 和 <code>argv</code> 的主要作用是允许程序接收和处理用户通过命令行传递的参数。这样你可以通过命令行控制程序的行为，比如：</p>
<ul>
<li>指定输入输出文件。</li>
<li>传递一些控制标志（如 <code>-debug</code>、<code>-verbose</code>）来调整程序行为。</li>
<li>执行特定操作或启用某些功能。</li>
</ul>
<p>其实就很像预处理的宏定义，帮助我们启动对应的逻辑选项。</p>
<p>当然你也可以输入一些你需要的路径等等等，有很多的选择根据你具体传的是什么吧。</p>
<p>示例：</p>
<ul>
<li><strong>调试和测试便捷</strong>：在开发过程中，特别是大型系统中，命令行参数可以用于启用&#x2F;禁用特定功能，调整日志级别，或传递配置信息。这使得开发者能够快速通过命令行改变程序行为而不需要每次修改代码或重新编译程序。</li>
</ul>
<pre><code>--debug
</code></pre>
<p> 参数启用调试模式：</p>
<pre><code>int main(int argc, char** argv) &#123;
    bool debug = false;
    for (int i = 1; i &lt; argc; ++i) &#123;
        if (std::string(argv[i]) == &quot;--debug&quot;) &#123;
            debug = true;
        &#125;
    &#125;
    if (debug) &#123;
        std::cout &lt;&lt; &quot;Debug mode enabled.&quot; &lt;&lt; std::endl;
    &#125;
    // 其他代码
&#125;
</code></pre>
<blockquote>
<h3 id="为什么有时只用-int-main-？"><a href="#为什么有时只用-int-main-？" class="headerlink" title="为什么有时只用 int main()？"></a>为什么有时只用 <code>int main()</code>？</h3><p>虽然 <code>int main(int argc, char** argv)</code> 提供了更强的灵活性和控制能力，但有些情况下我们更倾向于使用简单的 <code>int main()</code>：</p>
<ol>
<li><strong>程序不需要外部输入</strong>：如果你的程序不需要接受命令行参数，也不需要处理动态输入，那么使用 <code>int main()</code> 足够简单、直接。例如，一个图形化的桌面应用通常不需要通过命令行传递参数，因为所有交互都通过 GUI 完成。</li>
<li><strong>简化代码</strong>：在小型项目或简易的测试代码中，没有必要处理命令行参数的情况较多。为了保持代码简洁，<code>int main()</code> 可以减少不必要的复杂性。</li>
<li><strong>特定平台的限制</strong>：在某些嵌入式系统或特定环境下，命令行参数不可用。在这种情况下，<code>int main()</code> 是标准选择。</li>
</ol>
</blockquote>
<hr>
<h5 id="很好奇基于Hazel项目内部声明的application类，Sandbox项目内继承定义了一个Sandbox类，并且实现了父类的CreateApplication，返回一个子类Sandbox指针，为什么Hazel项目内的Enterpoint可以这样使用"><a href="#很好奇基于Hazel项目内部声明的application类，Sandbox项目内继承定义了一个Sandbox类，并且实现了父类的CreateApplication，返回一个子类Sandbox指针，为什么Hazel项目内的Enterpoint可以这样使用" class="headerlink" title="很好奇基于Hazel项目内部声明的application类，Sandbox项目内继承定义了一个Sandbox类，并且实现了父类的CreateApplication，返回一个子类Sandbox指针，为什么Hazel项目内的Enterpoint可以这样使用"></a>很好奇基于Hazel项目内部声明的application类，Sandbox项目内继承定义了一个Sandbox类，并且实现了父类的CreateApplication，返回一个子类Sandbox指针，为什么Hazel项目内的Enterpoint可以这样使用</h5><p>首先我们来看以下大体的示例图。</p>
<img src="./image-20241020202511173.png" alt="Hazel项目内的application类.h" style="zoom: 50%;" />

<img src="./image-20241020202529100.png" alt="Sandbox项目内的继承类" style="zoom:50%;" />

<img src="./image-20241020202606885.png" alt="Hazel内的enterPoint" style="zoom:50%;" />

<ol>
<li>首先就是extern为什么找到了项目之外的函数定义</li>
</ol>
<p><code>CreateApplication</code> 函数定义在 <code>app</code> 项目中，但通过 <code>extern</code> 声明，你可以在 <code>Hazel</code> 引擎的代码中调用它。编译器知道这个函数存在，但链接器会负责在实际运行时解析函数的具体位置，自然及时是在另外的启动像Sandbox，最后编译的时候也会自动找到其子类的定义。</p>
<p><code>Hazel::Application</code> 是一个基类，而 <code>Sandbox</code> 是从 <code>Hazel::Application</code> 派生的子类。</p>
<p>当 <code>CreateApplication()</code> 返回 <code>Hazel::Application*</code> 类型时，它实际上是返回了一个指向 <code>Sandbox</code> 对象的指针。</p>
<p>在 C++ 中，如果基类中的函数被声明为<strong>虚函数</strong>（<code>virtual</code>），那么即使你通过<strong>基类指针或引用调用该函数</strong>，程序仍然会调用子类的实现。这种机制叫做<strong>运行时多态</strong>。</p>
<hr>
<h4 id="为啥上个图的main函数命名没有引入头文件，为啥可以直接使用printf。"><a href="#为啥上个图的main函数命名没有引入头文件，为啥可以直接使用printf。" class="headerlink" title="为啥上个图的main函数命名没有引入头文件，为啥可以直接使用printf。"></a>为啥上个图的main函数命名没有引入头文件，为啥可以直接使用printf。</h4><hr>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
