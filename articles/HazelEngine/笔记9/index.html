
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>imgui和imgui事件 | yang_blog</title>
    <meta name="author" content="yang" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>YANG_BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YANG_BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>imgui和imgui事件</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/30
        </span>
        
        <span class="category">
            <a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                游戏引擎
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" style="color: #00bcd4">
                    游戏引擎
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="笔记9-imgui和imgui事件"><a href="#笔记9-imgui和imgui事件" class="headerlink" title="笔记9 imgui和imgui事件"></a>笔记9 imgui和imgui事件</h2><h3 id="再谈及imgui之前先说一说按照视频步骤拉取imgui的坑吧"><a href="#再谈及imgui之前先说一说按照视频步骤拉取imgui的坑吧" class="headerlink" title="再谈及imgui之前先说一说按照视频步骤拉取imgui的坑吧"></a>再谈及imgui之前先说一说按照视频步骤拉取imgui的坑吧</h3><p>由于版本问题，众所周知，肯定是不出意外的出意外的报错了。其实其实直接拿来用就好了，但是cherno既然是要举例子，就是暂时先把目前的教程的bug处理掉，bug也复现不出来（其实懒了，而且确实没必要，这里只是实例，后面会修改使用方法的）</p>
<span id="more"></span>

<p>主要就是imgui_opengl.cpp&#x2F;.h文件引入的时候需要处理。</p>
<p>就是注意cpp文件中，开头这样写一下。</p>
<img src="./image-20241112003311152.png" alt="image-20241112003311152" style="zoom: 80%;" />

<p>还有imgui.cpp中有一处需要修改，自己对照行数寻找，注意循环条件和window对象的修改。（这个最好记住，哪怕最新版本也注意一下）</p>
<img src="./image-20241112003411302.png" alt="image-20241112003411302" style="zoom:80%;" />







<p>（引入最新的imgui库好像有点问题需要修改，后面再补充上，而且前面跳过了glfw的imgui实现，而是自己去实现glfw的捕获功能，然后传递给imgui）</p>
<p>ImGui也是最为一个项目直接引入Hazel，premake里面都设置好了。</p>
<p>本质山imgui就是一个调试层，作为一个特殊的layer层级放置于覆盖层的上方。</p>
<p>我觉得在使用imgui之前我们可以先了解一下imgui的设计思路和布局等。</p>
<p>好吧先不管怎么样，我们先弄清楚imgui的结构和使用。</p>
<hr>
<p>imgui的设计大体分为了俩个部分。</p>
<ul>
<li>一个是核心的imgui的用户界面定义和用户交互的核心框架（包括imgui.h等等）</li>
</ul>
<img src="./image-20241109210558115-1732978413027-1.png" alt="image-20241109210558115" style="zoom: 80%;" />

<p>这里定义了用于创建按钮，文本，输入框等核心API，同时也有处理交互逻辑的处理等等。</p>
<p>为了实现跨平台的支持，作者将平台支持层，渲染支持层抽象出来，将各自的平台实现都放在backends（后端）文件夹中。</p>
<ul>
<li><strong>平台支持层</strong>（如 <code>imgui_impl_glfw.cpp</code>）：是 ImGui 与操作系统或窗口管理器的接口，用来获取输入事件、管理窗口等。不同平台的实现文件会负责在各自平台上获取输入事件，并将其传递给 ImGui 。</li>
</ul>
<p>具体的以glfw为例子，glfw可以监听玩家的外设操作，然后将事件转换为对应的数据和事件标记，传递给imgui的IO对象，然后imgui接受操作，内部处理这些交互逻辑。</p>
<ul>
<li><strong>渲染支持层</strong>（如 <code>imgui_impl_opengl.cpp</code>）：这是 ImGui 与渲I染 API（如 OpenGL、DirectX、Vulkan）的接口，负责将 ImGui 的渲染数据转换为实际的绘制操作。后端渲染层将 UI 组件的绘制命令转换为图形 API 调用，以在屏幕上绘制出 ImGui 生成的界面。</li>
</ul>
<p>完整的imgui使用需要指定你使用的平台层和渲染层，显然我们的项目使用的是glfw和openGL。</p>
<p>那么就需要使用<code>imgui_impl_glfw.cpp</code>，<code>imgui_impl_glfw.h</code>，<code>imgui_impl_opengl.cpp</code>，<code>imgui_impl_opengl.h</code></p>
<hr>
<p>可以参考官方文档（[wiki](<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/docs/BACKENDS.md">imgui&#x2F;docs&#x2F;BACKENDS.md at master · ocornut&#x2F;imgui</a>)），同时我摘录一部分。</p>
<p>了解核心 Dear ImGui 库（根文件夹中的文件）和我们在此处描述的后端（backends&#x2F; 文件夹）之间的区别非常重要。</p>
<p>首先介绍了ImGui库</p>
<p>ImGui 具有高度的可移植性，只需要运行和渲染一些东西，通常：</p>
<ul>
<li><p>必需：提供鼠标&#x2F;键盘输入（馈送到 <code>ImGuiIO</code> 结构中）。</p>
</li>
<li><p>必需：将字体图集纹理上传到图形内存中。</p>
</li>
<li><p>必需：使用剪切矩形渲染索引纹理三角形。</p>
</li>
<li><p>可选：自定义纹理绑定支持。</p>
</li>
<li><p>可选：clipboard 支持。</p>
</li>
<li><p>可选：游戏手柄支持。</p>
</li>
<li><p>可选：鼠标光标形状支持。</p>
</li>
<li><p>可选：IME 支持。</p>
</li>
<li><p>可选：多视口支持。等。</p>
</li>
</ul>
<p>然后介绍了backends中的文件</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends">backends&#x2F;</a> 文件夹包含流行平台&#x2F;图形 API 的后端，您可以在应用程序或引擎中使用它们来轻松集成 Dear ImGui。</strong>每个后端通常自包含在一对文件中：imgui_impl_XXXX.cpp + imgui_impl_XXXX.h。</p>
<ul>
<li><p>“平台”后端负责：鼠标&#x2F;键盘&#x2F;游戏手柄输入、光标形状、计时和窗口。e.g. Windows (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_win32.cpp">imgui_impl_win32.cpp</a>), GLFW (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_glfw.cpp">imgui_impl_glfw.cpp</a>), SDL2 (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_sdl2.cpp">imgui_impl_sdl2.cpp</a>), etc.</p>
</li>
<li><p>‘Renderer’ 后端负责：创建图集纹理和渲染 imgui 绘制数据。e.g. DirectX11 (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_dx11.cpp">imgui_impl_dx11.cpp</a>), OpenGL&#x2F;WebGL (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_opengl3.cpp">imgui_impl_opengl3.cpp</a>), Vulkan (<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_vulkan.cpp">imgui_impl_vulkan.cpp</a>), etc.</p>
</li>
</ul>
<p>附上文档里面使用的glfw和openGL的使用例子。</p>
<pre><code class="CPP">----
//Add to Includes: 添加到包含：
    
#include &quot;imgui.h&quot;
#include &quot;imgui_impl_glfw.h&quot;
#include &quot;imgui_impl_opengl3.h&quot;
----
//Add to Initialization: 添加到初始化：
    
// Setup Dear ImGui context
IMGUI_CHECKVERSION();
ImGui::CreateContext();
ImGuiIO&amp; io = ImGui::GetIO();
io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // IF using Docking Branch

// Setup Platform/Renderer backends
ImGui_ImplGlfw_InitForOpenGL(YOUR_WINDOW, true);          // Second param install_callback=true will install GLFW callbacks and chain to existing ones.
ImGui_ImplOpenGL3_Init();

----------
//Add to start of main loop:
//添加到 main 循环的开头：
    
// (Your code calls glfwPollEvents())
// ...
// Start the Dear ImGui frame
ImGui_ImplOpenGL3_NewFrame();
ImGui_ImplGlfw_NewFrame();
ImGui::NewFrame();
ImGui::ShowDemoWindow(); // Show demo window! :)

----------
//Add to end of main loop:
//添加到 main 循环的末尾： 
    
    
// Rendering
// (Your code clears your framebuffer, renders your other stuff etc.)
ImGui::Render();
ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
// (Your code calls glfwSwapBuffers() etc.)
-----------
//Add to Shutdown: 添加到关机：
    
ImGui_ImplOpenGL3_Shutdown();
ImGui_ImplGlfw_Shutdown();
ImGui::DestroyContext();

----------
</code></pre>
<hr>
<p>在layer层的示例中，cherno将glfw层的作用层层拆分，融合到示例里面了。</p>
<p>暂且先解释以下imgui_glfw_cpp中实现的功能。</p>
<p>imgui_glfw_cpp文件中，我们可以参照上面的使用，参考几个主要功能</p>
<ul>
<li>首先就是初始化<code>ImGui_ImplGlfw_InitForOpenGL(YOUR_WINDOW, true);</code></li>
</ul>
<blockquote>
<ol>
<li><p>初始化 ImGui 后端数据，配置与平台相关的设置。</p>
</li>
<li><p>设置与剪贴板、鼠标光标、错误回调等相关的功能。</p>
</li>
<li><p>安装 GLFW 的回调函数以处理各种平台事件。</p>
</li>
<li><p>注册显示器和多视口支持。</p>
</li>
</ol>
<p>处理 Emscripten 特有的回调（如果在该平台下运行）</p>
<hr>
<p>在cherno的示例中我们需要的注意就以下几个功能</p>
<ol>
<li>设置后端标志（<code>BackendFlags</code>）：支持键盘输入，光标等。</li>
<li>剪贴板是最后留给玩家的实现的作业。</li>
<li>安装回调函数，在示例中我们就在imguiLayer中直接像glfw的注册函数。</li>
</ol>
</blockquote>
<ul>
<li>然后就是更新<code>ImGui_ImplGlfw_NewFrame();</code></li>
</ul>
<blockquote>
<ol>
<li>获取 ImGuiIO 和后端数据</li>
<li>设置显示尺寸和比例（windowSize和frameBufferSize）</li>
<li>设置时间步长</li>
<li>更新鼠标数据和光标</li>
<li>更新游戏手柄（如果启用并可用）</li>
</ol>
<hr>
<p>首先解释一下明明回调函数中更新了对应的鼠标等设置，但是为什么要在这里统一更新，</p>
<p>搜索给的答案是:</p>
<p>事件本身并不保证在每一帧的开始时都能更新，因此，<code>ImGui_ImplGlfw_NewFrame()</code> 会在每帧开始时，从 GLFW 获取当前的输入数据，并将其统一更新到 <code>ImGuiIO</code> 中，确保 ImGui 正确地响应当前帧的所有输入。</p>
<p>而根据我看的来说，虽然鼠标等回调直接可以根据回调改变，但是调节屏幕尺寸大小等等，都是先标记然后在new_frame中处理屏幕等需要统一处理的，至于原因，也不太清楚。</p>
</blockquote>
<blockquote>
<hr>
<p>Cherno示例中使用的</p>
<ol>
<li>设置显示尺寸和比例（windowSize和frameBufferSize是不同的概念，后面解释）</li>
<li>设置时间步长</li>
</ol>
</blockquote>
<ul>
<li>最后就是关闭了<code>ImGui_ImplGlfw_Shutdown();</code></li>
</ul>
<blockquote>
<ol>
<li>关闭平台接口</li>
<li>还原 GLFW 回调（如果需要）</li>
<li>销毁鼠标光标</li>
<li>清理平台后端数据</li>
</ol>
<hr>
<p>没啥印象，暂时不知道哪里用了。</p>
</blockquote>
<p>至于opengL的功能，哈哈哈看我什么时候无聊搜搜看看补上吧</p>
<hr>
<p>接下来我们就来看看，cherno编写示例中的步骤。</p>
<ul>
<li>先将imgui_opengl3的文件引入修改为ImGuiOpenGLRenderer名字，对里面的文件引入稍加修改（至于修改方法明天再来解释）</li>
<li>然后就是参考example_glfw_opengl3的文件找到参考，编写imguiLayer中的代码。</li>
</ul>
<ol>
<li>例如初始化<code>OnAttach</code></li>
</ol>
<pre><code class="CPP">void ImGuiLayer::OnAttach()
&#123;
    ImGui::CreateContext();
    ImGui::StyleColorsDark();
        ImGuiIO&amp; io = ImGui::GetIO();
        io.BackendFlags |=ImGuiBackendFlags_HasMouseCursors;//表明支持鼠标光标。
        io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;//表明可以处理 io.WantSetMousePos 请求。
    
    io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = GLFW_KEY_RIGHT;
    //....省略映射
    
    ImGui_ImplOpenGL3_Init(&quot;#version 410&quot;);
&#125;
</code></pre>
<ul>
<li>前俩个就是创建上下文，和设置背景色风格</li>
<li>然后就是支持设置（原本是imgui_glfw的初始化一部分）</li>
<li>这个映射其实没必要的，但是为了当时作为示例实现，直接设置了，实际上glfw监视映射的键码需要映射到ImGui的键码只需要一个函数就能实现源文件就是<code>ImGui_ImplGlfw_KeyToImGuiKey</code>函数实现的，这里纯粹是为了响应自己写的event函数，利用event的<code>GetKeyCode</code>等返回的glfw键码，方便直接将输入直接反馈给imgui（然后imgui处理交互逻辑）</li>
</ul>
<pre><code class="CPP">bool ImGuiLayer::OnKeyReleasedEvent(KeyReleasedEvent&amp; e)
    &#123;
        ImGuiIO&amp; io = ImGui::GetIO();
        io.KeysDown[e.GetKeyCode()] = false;
        return false;
    &#125;
</code></pre>
<ul>
<li>最后就是imgui_opengl的初始化。</li>
</ul>
<ol start="2">
<li>设置imguiLayer的OnEvent事件</li>
</ol>
<blockquote>
<p> 为此创建了一个专门处理文字输入的事件（KeyTypedEvent）,没想到还有这种事件，暂时还不太了解。</p>
</blockquote>
<p>为当前层级创建事件分配器，为不同的事件注册对应的回调函数。</p>
<pre><code class="CPP">void ImGuiLayer::OnEvent(Event&amp; event)
    &#123;
        EventDispatcher dispatcher(event);
        dispatcher.Dispatch&lt;KeyTypedEvent&gt;(HZ_BIND_EVENT_FN(ImGuiLayer::OnKeyTypedEvent));
        //...
    &#125;
</code></pre>
<ol start="3">
<li>编写对应的回调函数，就展示一个（return false表示当前事件已被处理，不需要再往下传递）</li>
</ol>
<p>这里面的回调函数，都直接把输入的操作传给imgui的IO中，简化了imgui_glfw中的处理相关设计，统一回调函数处理了。</p>
<pre><code class="CPP">bool ImGuiLayer::OnMouseButtonPressedEvent(MouseButtonPressedEvent&amp; e)
    &#123;
        ImGuiIO&amp; io = ImGui::GetIO();
        io.MouseDown[e.GetMouseButton()] = true;
        return false;
    &#125;
</code></pre>
<ol start="4">
<li>设置imguiLayer的update</li>
</ol>
<pre><code class="CPP">void ImGuiLayer::OnUpdate()
    &#123;
        ImGuiIO&amp; io = ImGui::GetIO();
        Application&amp; app=Application::Get();		//为此还专门为application创建了一个单例。
    
        //设置windowSize
        io.DisplaySize = ImVec2(app.GetWindow().GetWidth(),app.GetWindow().GetHeight());
        
        //计算步长
        float time = (float)glfwGetTime();
        io.DeltaTime = m_Time &gt; 0.0f ? (time - m_Time) : (1.0 / 60.0f);
        m_Time = time;
        
        //统一更新
        ImGui_ImplOpenGL3_NewFrame();
        ImGui::NewFrame();
        
        //示例imgui展示
        static bool show = true;
        ImGui::ShowDemoWindow(&amp;show);
    
        //绘制，绘制数据
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    &#125;
</code></pre>
<p>前面俩步其实就是从imgui_glfw中拆分出来的。</p>
<p>第一步设置windowsize（其实第二步还有设置帧缓冲frameBufferSize）</p>
<img src="./image-20241110110351170.png" alt="image-20241110110351170" style="zoom:80%;" />

<p>他将帧缓冲的设置放在了屏幕Resize回调函数里面（OnWindowResizeEvent），这分的有点散。</p>
<pre><code class="CPP">bool ImGuiLayer::OnWindowResizeEvent(WindowResizeEvent&amp; e)
    &#123;
        ImGuiIO&amp; io = ImGui::GetIO();
        io.DisplaySize = ImVec2(e.GetWidth(), e.GetHeight());
        io.DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
        glViewport(0, 0, e.GetWidth(), e.GetHeight());			
        return false;
    &#125;
</code></pre>
<blockquote>
<p><strong>视图（Viewport）</strong>是 OpenGL 中的一个矩形区域，用来指定渲染内容应该出现在窗口的什么位置和多大范围内。具体地说，当调用 <code>glViewport(x, y, width, height)</code> 时，OpenGL 会将绘制的内容缩放并放置在该区域内，所有后续渲染操作的坐标都会被映射到这个区域内。</p>
<p>换句话说，如果你设置</p>
<p><code>glViewport(e.GetWidth()/2,e.GetHeight()/2, e.GetWidth()/2, e.GetHeight()/2);</code></p>
<p>那么所有绘制的都会浓缩在右上角1&#x2F;4区域，就是参考的窗口绘制范围。</p>
<p>（貌似这里没啥用，openGL中Renderer会处理视口问题）</p>
<hr>
<p><strong>帧缓冲区（Framebuffer）</strong> 是一个内存区域，保存了每个像素的颜色信息。它通常包括图像的宽度、高度以及每个像素的颜色、深度等信息。在图形渲染过程中，GPU 会将图像渲染到帧缓冲区，渲染完成后，帧缓冲区的内容会被显示到屏幕上。</p>
<p><code>window size</code> 是指用户在屏幕上看到的窗口的实际显示尺寸，通常是窗口的<strong>逻辑尺寸</strong>，也就是窗口的宽度和高度，不考虑显示器的 DPI 缩放或其他显示因素。</p>
<p>也就是说windowsize是逻辑直观上的大小，但是根据电脑显示屏分辨率的不同，需要对实际大小做出调整，分辨率更高的像素点更加密集，直观上的大小，需要更多的像素点，所以需要合理的缩放（DPI）。</p>
<p>在一个常规的 1920x1080 分辨率的显示器上，假设操作系统使用了 2x 的 DPI 缩放，那么帧缓冲区的尺寸可能是 1600x1200，而窗口大小（即显示的窗口尺寸）可能是 800x600。</p>
</blockquote>
<p>第二步就是计算步长，时间差暂时也不考虑。</p>
<p>第三步就是明显的帧更新</p>
<p>第四步就是绘制了，关于第四步，imgui_Render其实是处理所有控件数据，然后生成绘图指令，最后openGL再处理这些数据绘制。</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 yang_blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;yang
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
